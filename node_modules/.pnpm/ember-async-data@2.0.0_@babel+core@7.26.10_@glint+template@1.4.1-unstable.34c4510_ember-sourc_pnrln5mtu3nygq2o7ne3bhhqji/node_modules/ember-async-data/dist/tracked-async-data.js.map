{"version":3,"file":"tracked-async-data.js","sources":["../src/tracked-async-data.ts"],"sourcesContent":["import { tracked } from '@glimmer/tracking';\nimport { assert } from '@ember/debug';\nimport { buildWaiter } from '@ember/test-waiters';\n\nconst waiter = buildWaiter('ember-async-data');\n\n/** A very cheap representation of the of a promise. */\ntype StateRepr<T> =\n  | [tag: 'PENDING']\n  | [tag: 'RESOLVED', value: T]\n  | [tag: 'REJECTED', error: unknown];\n\n// We only need a single instance of the pending state in our system, since it\n// is otherwise unparameterized (unlike the resolved and rejected states).\nconst PENDING = ['PENDING'] as [tag: 'PENDING'];\n\n// This class exists so that the state can be *wholly* private to outside\n// consumers, but its tracked internals can be both read and written directly by\n// `TrackedAsyncData` itself. The initial state of every `TrackedAsyncData` is\n// `PENDING`, though it may immediately become resolved for some `Promise`\n// instances (e.g. with a `Promise.resolve`).\nclass State<T> {\n  @tracked data: StateRepr<T> = PENDING;\n}\n\n// NOTE: this class is the implementation behind the types; the public types\n// layer on additional safety. See below! Additionally, the docs for the class\n// itself are applied to the export, not to the class, so that they will appear\n// when users refer to *that*.\nclass _TrackedAsyncData<T> {\n  #token: unknown;\n\n  /**\n    @param promise The promise to load.\n   */\n  constructor(data: T | Promise<T>) {\n    if (this.constructor !== _TrackedAsyncData) {\n      throw new Error('tracked-async-data cannot be subclassed');\n    }\n\n    if (!isPromiseLike(data)) {\n      this.#state.data = ['RESOLVED', data];\n      return;\n    }\n\n    const promise = data;\n    this.#token = waiter.beginAsync();\n\n    // Otherwise, we know that haven't yet handled that promise anywhere in the\n    // system, so we continue creating a new instance.\n    promise.then(\n      (value) => {\n        this.#state.data = ['RESOLVED', value];\n        waiter.endAsync(this.#token);\n      },\n      (error) => {\n        this.#state.data = ['REJECTED', error];\n        waiter.endAsync(this.#token);\n      },\n    );\n  }\n\n  /**\n    The internal state management for the promise.\n\n    - `readonly` so it cannot be mutated by the class itself after instantiation\n    - uses true native privacy so it cannot even be read (and therefore *cannot*\n      be depended upon) by consumers.\n   */\n  readonly #state = new State<T>();\n\n  /**\n   * The resolution state of the promise.\n   */\n  get state(): State<T>['data'][0] {\n    return this.#state.data[0];\n  }\n\n  /**\n    The value of the resolved promise.\n\n    @note It is only valid to access `error` when `.isError` is true, that is,\n      when `TrackedAsyncData.state` is `\"ERROR\"`.\n    @warning You should not rely on this returning `T | null`!\n   */\n  get value(): T | null {\n    assert(\n      \"Accessing `value` when TrackedAsyncData is not in the resolved state is not supported. Always check that `.state` is `'RESOLVED'` or that `.isResolved` is `true` before accessing this property.\",\n      this.#state.data[0] === 'RESOLVED',\n    );\n\n    return this.#state.data[0] === 'RESOLVED' ? this.#state.data[1] : null;\n  }\n\n  /**\n    The error of the rejected promise.\n\n    @note It is only valid to access `error` when `.isError` is true, that is,\n      when `TrackedAsyncData.state` is `\"ERROR\"`.\n    @warning You should not rely on this returning `null` when the state is not\n      `\"ERROR\"`!\n   */\n  get error(): unknown {\n    assert(\n      \"Accessing `error` when TrackedAsyncData is not in the rejected state is not supported. Always check that `.state` is `'REJECTED'` or that `.isRejected` is `true` before accessing this property.\",\n      this.#state.data[0] === 'REJECTED',\n    );\n\n    return this.#state.data[0] === 'REJECTED' ? this.#state.data[1] : null;\n  }\n\n  /**\n    Is the state `\"PENDING\"`.\n   */\n  get isPending(): boolean {\n    return this.state === 'PENDING';\n  }\n\n  /** Is the state `\"RESOLVED\"`? */\n  get isResolved(): boolean {\n    return this.state === 'RESOLVED';\n  }\n\n  /** Is the state `\"REJECTED\"`? */\n  get isRejected(): boolean {\n    return this.state === 'REJECTED';\n  }\n\n  // SAFETY: casts are safe because we uphold these invariants elsewhere in the\n  // class. It would be great if we could guarantee them statically, but getters\n  // do not return information about the state of the class well.\n  toJSON(): JSONRepr<T> {\n    const { isPending, isResolved, isRejected } = this;\n    if (isPending) {\n      return { isPending, isResolved, isRejected } as JSONRepr<T>;\n    } else if (isResolved) {\n      return {\n        isPending,\n        isResolved,\n        value: this.value,\n        isRejected,\n      } as JSONRepr<T>;\n    } else {\n      return {\n        isPending,\n        isResolved,\n        isRejected,\n        error: this.error,\n      } as JSONRepr<T>;\n    }\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON(), null, 2);\n  }\n}\n\n/**\n  The JSON representation of a `TrackedAsyncData`, useful for e.g. logging.\n\n  Note that you cannot reconstruct a `TrackedAsyncData` *from* this, because it\n  is impossible to get the original promise when in a pending state!\n */\nexport type JSONRepr<T> =\n  | { isPending: true; isResolved: false; isRejected: false }\n  | { isPending: false; isResolved: true; isRejected: false; value: T }\n  | { isPending: false; isResolved: false; isRejected: true; error: unknown };\n\n// The exported type is the intersection of three narrowed interfaces. Doing it\n// this way has two nice benefits:\n//\n// 1.  It allows narrowing to work. For example:\n//\n//     ```ts\n//     let data = new TrackedAsyncData(Promise.resolve(\"hello\"));\n//     if (data.isPending) {\n//       data.value;  // null\n//       data.error;  // null\n//     } else if (data.isPending) {\n//       data.value;  // null\n//       data.error;  // null\n//     } else if (data.isRejected) {\n//       data.value;  // null\n//       data.error;  // unknown, can now be narrowed\n//     }\n//     ```\n//\n//     This dramatically improves the usability of the type in type-aware\n//     contexts (including with templates when using Glint!)\n//\n// 2.  Using `interface extends` means that (a) it is guaranteed to be a subtype\n//     of the `_TrackedAsyncData` type, (b) that the docstrings applied to the\n//     base type still work, and (c) that the types which are *common* to the\n//     shared implementations (i.e. `.toJSON()` and `.toString()`) are shared\n//     automatically.\n\ninterface Pending<T> extends _TrackedAsyncData<T> {\n  state: 'PENDING';\n  isPending: true;\n  isResolved: false;\n  isRejected: false;\n  value: null;\n  error: null;\n}\n\ninterface Resolved<T> extends _TrackedAsyncData<T> {\n  state: 'RESOLVED';\n  isPending: false;\n  isResolved: true;\n  isRejected: false;\n  value: T;\n  error: null;\n}\n\ninterface Rejected<T> extends _TrackedAsyncData<T> {\n  state: 'REJECTED';\n  isPending: false;\n  isResolved: false;\n  isRejected: true;\n  value: null;\n  error: unknown;\n}\n\n/**\n  An autotracked `Promise` handler, representing asynchronous data.\n\n  Given a `Promise` instance, a `TrackedAsyncData` behaves exactly lik the\n  original `Promise`, except that it makes the state of the `Promise` visible\n  via tracked state, so you can check whether the promise is pending, resolved,\n  or rejected; and so you can get the value if it has resolved or the error if\n  it has rejected.\n\n  Every `Promise` in the system is guaranteed to be associated with at most a\n  single `TrackedAsyncData`.\n\n  ## Example\n\n  ```ts\n  import Component from '@glimmer/component';\n  import { cached } from '@glimmer/tracking';\n  import { inject as service } from '@ember/service';\n  import TrackedAsyncData from 'ember-async-data/tracked-async-data';\n\n  export default class SmartProfile extends Component<{ id: number }> {\n    @service store;\n\n    @cached\n    get someData() {\n      let recordPromise = this.store.findRecord('user', this.args.id);\n      return new TrackedAsyncData(recordPromise);\n    }\n  }\n  ```\n\n  And a corresponding template:\n\n  ```hbs\n  {{#if this.someData.isResolved}}\n    <PresentTheData @data={{this.someData.data}} />\n  {{else if this.someData.isPending}}\n    <LoadingSpinner />\n  {{else if this.someData.isRejected}}\n    <p>\n      Whoops! Looks like something went wrong!\n      {{this.someData.error.message}}\n    </p>\n  {{/if}}\n  ```\n */\ntype TrackedAsyncData<T> = Pending<T> | Resolved<T> | Rejected<T>;\nconst TrackedAsyncData = _TrackedAsyncData as new <T>(\n  data: T | Promise<T>,\n) => TrackedAsyncData<T>;\nexport default TrackedAsyncData;\n\n/** Utility type to check whether the string `key` is a property on an object */\nfunction has<K extends PropertyKey, T extends object>(\n  key: K,\n  t: T,\n): t is T & Record<K, unknown> {\n  return key in t;\n}\n\nfunction isPromiseLike(data: unknown): data is PromiseLike<unknown> {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    has('then', data) &&\n    typeof data.then === 'function'\n  );\n}\n"],"names":["waiter","buildWaiter","PENDING","State","g","prototype","tracked","i","void 0","_TrackedAsyncData","constructor","data","Error","isPromiseLike","promise","beginAsync","then","value","endAsync","error","state","assert","isPending","isResolved","isRejected","toJSON","toString","JSON","stringify","TrackedAsyncData","has","key","t"],"mappings":"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AI,CAACA;OACb;AACH;AACF;AAEAO,EAAAA,QAAQA,GAAW;AACjB,IAAA,OAAOC,IAAI,CAACC,SAAS,CAAC,IAAI,CAACH,MAAM,EAAE,EAAE,IAAI,EAAE,CAAC,CAAC;AAC/C;AACF;;AAEA;AACA;;AAEA;AACA;AACA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA6BA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEMI,MAAAA,gBAAgB,GAAGpB;;AAKzB;AACA,SAASqB,GAAGA,CACVC,GAAM,EACNC,CAAI,EACyB;EAC7B,OAAOD,GAAG,IAAIC,CAAC;AACjB;AAEA,SAASnB,aAAaA,CAACF,IAAa,EAAgC;EAClE,OACE,OAAOA,IAAI,KAAK,QAAQ,IACxBA,IAAI,KAAK,IAAI,IACbmB,GAAG,CAAC,MAAM,EAAEnB,IAAI,CAAC,IACjB,OAAOA,IAAI,CAACK,IAAI,KAAK,UAAU;AAEnC;;;;"}