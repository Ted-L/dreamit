{"version":3,"file":"index.cjs","sources":["../../lib/source/loc/kinds.ts","../../lib/parser/handlebars-node-visitors.ts","../../lib/v2/objects/constants.ts","../../lib/v2/objects/resolution.ts"],"sourcesContent":["/**\n * We have already computed the character position of this offset or span.\n */\nexport type CharOffsetKind = 'CharPosition';\nexport const CHAR_OFFSET_KIND: CharOffsetKind = 'CharPosition';\n/**\n * This offset or span was instantiated with a Handlebars SourcePosition or SourceLocation. Its\n * character position will be computed on demand.\n */\nexport type HbsPositionKind = 'HbsPosition';\nexport const HBS_POSITION_KIND: HbsPositionKind = 'HbsPosition';\n/**\n * for (rare) situations where a node is created but there was no source location (e.g. the name\n * \"default\" in default blocks when the word \"default\" never appeared in source). This is used\n * by the internals when there is a legitimate reason for the internals to synthesize a node\n * with no location.\n */\nexport type InternalSyntheticKind = 'InternalsSynthetic';\nexport const INTERNAL_SYNTHETIC_KIND: InternalSyntheticKind = 'InternalsSynthetic';\n\n/**\n * For situations where a node represents zero parts of the source (for example, empty arguments).\n * In general, we attempt to assign these nodes *some* position (empty arguments can be\n * positioned immediately after the callee), but it's not always possible\n */\nexport type NonExistentKind = 'NonExistent';\nexport const NON_EXISTENT_KIND: NonExistentKind = 'NonExistent';\n\n/**\n * For situations where a source location was expected, but it didn't correspond to the node in\n * the source. This happens if a plugin creates broken locations.\n */\nexport type BrokenKind = 'Broken';\nexport const BROKEN_KIND: BrokenKind = 'Broken';\n\nexport type OffsetKind = CharOffsetKind | HbsPositionKind | InvisibleKind;\n\n/**\n * These kinds  describe spans that don't have a concrete location in the original source.\n */\nexport type InvisibleKind = BrokenKind | InternalSyntheticKind | NonExistentKind;\n\nexport function isInvisible(kind: OffsetKind): kind is InvisibleKind {\n  return kind !== CHAR_OFFSET_KIND && kind !== HBS_POSITION_KIND;\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\nimport type { Nullable, Recast } from '@glimmer/interfaces';\nimport type { TokenizerState } from 'simple-html-tokenizer';\nimport { assert, getLast, isPresentArray, unwrap } from '@glimmer/debug-util';\n\nimport type { ParserNodeBuilder, StartTag } from '../parser';\nimport type { SourceOffset, SourceSpan } from '../source/span';\nimport type * as ASTv1 from '../v1/api';\nimport type * as HBS from '../v1/handlebars-ast';\n\nimport { Parser } from '../parser';\nimport { NON_EXISTENT_LOCATION } from '../source/location';\nimport { generateSyntaxError } from '../syntax-error';\nimport { appendChild, isHBSLiteral, printLiteral } from '../utils';\nimport b from '../v1/parser-builders';\n\nconst BEFORE_ATTRIBUTE_NAME = 'beforeAttributeName' as TokenizerState.beforeAttributeName;\nconst ATTRIBUTE_VALUE_UNQUOTED = 'attributeValueUnquoted' as TokenizerState.attributeValueUnquoted;\n\nexport interface PendingError {\n  mustache(span: SourceSpan): never;\n  eof(offset: SourceOffset): never;\n}\n\nexport abstract class HandlebarsNodeVisitors extends Parser {\n  // Because we interleave the HTML and HBS parsing, sometimes the HTML\n  // tokenizer can run out of tokens when we switch into {{...}} or reached\n  // EOF. There are positions where neither of these are expected, and it would\n  // like to generate an error, but there is no span to attach the error to.\n  // This allows the HTML tokenization to stash an error message and the next\n  // mustache visitor will attach the message to the appropriate span and throw\n  // the error.\n  protected pendingError: Nullable<PendingError> = null;\n\n  abstract override appendToCommentData(s: string): void;\n  abstract override beginAttributeValue(quoted: boolean): void;\n  abstract override finishAttributeValue(): void;\n\n  parse(program: HBS.Program, blockParams: string[]): ASTv1.Template {\n    let node = b.template({\n      body: [],\n      blockParams,\n      loc: this.source.spanFor(program.loc),\n    });\n\n    let template = this.parseProgram(node, program);\n\n    // TODO: we really need to verify that the tokenizer is in an acceptable\n    // state when we are \"done\" parsing. For example, right now, `<foo` parses\n    // into `Template { body: [] }` which is obviously incorrect\n\n    this.pendingError?.eof(template.loc.getEnd());\n\n    return template;\n  }\n\n  Program(program: HBS.Program, blockParams?: ASTv1.VarHead[]): ASTv1.Block {\n    // The abstract signature doesn't have the blockParams argument, but in\n    // practice we can only come from this.BlockStatement() which adds the\n    // extra argument for us\n    assert(\n      Array.isArray(blockParams),\n      '[BUG] Program in parser unexpectedly called without block params'\n    );\n\n    let node = b.blockItself({\n      body: [],\n      params: blockParams,\n      chained: program.chained,\n      loc: this.source.spanFor(program.loc),\n    });\n\n    return this.parseProgram(node, program);\n  }\n\n  private parseProgram<T extends ASTv1.ParentNode>(node: T, program: HBS.Program): T {\n    if (program.body.length === 0) {\n      return node;\n    }\n\n    let poppedNode;\n\n    try {\n      this.elementStack.push(node);\n\n      for (let child of program.body) {\n        this.acceptNode(child);\n      }\n    } finally {\n      poppedNode = this.elementStack.pop();\n    }\n\n    // Ensure that that the element stack is balanced properly.\n    if (node !== poppedNode) {\n      if (poppedNode?.type === 'ElementNode') {\n        throw generateSyntaxError(`Unclosed element \\`${poppedNode.tag}\\``, poppedNode.loc);\n      } else {\n        // If the stack is not balanced, then it is likely our own bug, because\n        // any unclosed Handlebars blocks should already been caught by now\n        assert(poppedNode !== undefined, '[BUG] empty parser elementStack');\n        assert(false, `[BUG] mismatched parser elementStack node: ${node.type}`);\n      }\n    }\n\n    return node;\n  }\n\n  BlockStatement(block: HBS.BlockStatement): ASTv1.BlockStatement | void {\n    if (this.tokenizer.state === 'comment') {\n      this.appendToCommentData(this.sourceForNode(block));\n      return;\n    }\n\n    if (this.tokenizer.state !== 'data' && this.tokenizer.state !== 'beforeData') {\n      throw generateSyntaxError(\n        'A block may only be used inside an HTML element or another block.',\n        this.source.spanFor(block.loc)\n      );\n    }\n\n    const { path, params, hash } = acceptCallNodes(this, block);\n    const loc = this.source.spanFor(block.loc);\n\n    // Backfill block params loc for the default block\n    let blockParams: ASTv1.VarHead[] = [];\n\n    if (block.program.blockParams?.length) {\n      // Start from right after the hash\n      let span = hash.loc.collapse('end');\n\n      // Extend till the beginning of the block\n      if (block.program.loc) {\n        span = span.withEnd(this.source.spanFor(block.program.loc).getStart());\n      } else if (block.program.body[0]) {\n        span = span.withEnd(this.source.spanFor(block.program.body[0].loc).getStart());\n      } else {\n        // ...or if all else fail, use the end of the block statement\n        // this can only happen if the block statement is empty anyway\n        span = span.withEnd(loc.getEnd());\n      }\n\n      // Now we have a span for something like this:\n      //\n      //   {{#foo bar baz=bat as |wow wat|}}\n      //                     ~~~~~~~~~~~~~~~\n      //\n      // Or, if we are unlucky:\n      //\n      // {{#foo bar baz=bat as |wow wat|}}{{/foo}}\n      //                   ~~~~~~~~~~~~~~~~~~~~~~~\n      //\n      // Either way, within this span, there should be exactly two pipes\n      // fencing our block params, neatly whitespace separated and with\n      // legal identifiers only\n      const content = span.asString();\n      let skipStart = content.indexOf('|') + 1;\n      const limit = content.indexOf('|', skipStart);\n\n      for (const name of block.program.blockParams) {\n        let nameStart: number;\n        let loc: SourceSpan;\n\n        if (skipStart >= limit) {\n          nameStart = -1;\n        } else {\n          nameStart = content.indexOf(name, skipStart);\n        }\n\n        if (nameStart === -1 || nameStart + name.length > limit) {\n          skipStart = limit;\n          loc = this.source.spanFor(NON_EXISTENT_LOCATION);\n        } else {\n          skipStart = nameStart;\n          loc = span.sliceStartChars({ skipStart, chars: name.length });\n          skipStart += name.length;\n        }\n\n        blockParams.push(b.var({ name, loc }));\n      }\n    }\n\n    // These are bugs in Handlebars upstream\n    if (!block.program.loc) {\n      block.program.loc = NON_EXISTENT_LOCATION;\n    }\n\n    if (block.inverse && !block.inverse.loc) {\n      block.inverse.loc = NON_EXISTENT_LOCATION;\n    }\n\n    const program = this.Program(block.program, blockParams);\n    const inverse = block.inverse ? this.Program(block.inverse, []) : null;\n\n    const node = b.block({\n      path,\n      params,\n      hash,\n      defaultBlock: program,\n      elseBlock: inverse,\n      loc: this.source.spanFor(block.loc),\n      openStrip: block.openStrip,\n      inverseStrip: block.inverseStrip,\n      closeStrip: block.closeStrip,\n    });\n\n    const parentProgram = this.currentElement();\n\n    appendChild(parentProgram, node);\n  }\n\n  MustacheStatement(rawMustache: HBS.MustacheStatement): ASTv1.MustacheStatement | void {\n    this.pendingError?.mustache(this.source.spanFor(rawMustache.loc));\n\n    const { tokenizer } = this;\n\n    if (tokenizer.state === 'comment') {\n      this.appendToCommentData(this.sourceForNode(rawMustache));\n      return;\n    }\n\n    let mustache: ASTv1.MustacheStatement;\n    const { escaped, loc, strip } = rawMustache;\n\n    if ('original' in rawMustache.path && rawMustache.path.original === '...attributes') {\n      throw generateSyntaxError(\n        'Illegal use of ...attributes',\n        this.source.spanFor(rawMustache.loc)\n      );\n    }\n\n    if (isHBSLiteral(rawMustache.path)) {\n      mustache = b.mustache({\n        path: this.acceptNode<(typeof rawMustache.path)['type']>(rawMustache.path),\n        params: [],\n        hash: b.hash({ pairs: [], loc: this.source.spanFor(rawMustache.path.loc).collapse('end') }),\n        trusting: !escaped,\n        loc: this.source.spanFor(loc),\n        strip,\n      });\n    } else {\n      const { path, params, hash } = acceptCallNodes(\n        this,\n        rawMustache as HBS.MustacheStatement & {\n          path: HBS.PathExpression | HBS.SubExpression;\n        }\n      );\n      mustache = b.mustache({\n        path,\n        params,\n        hash,\n        trusting: !escaped,\n        loc: this.source.spanFor(loc),\n        strip,\n      });\n    }\n\n    switch (tokenizer.state) {\n      // Tag helpers\n      case 'tagOpen':\n      case 'tagName':\n        throw generateSyntaxError(`Cannot use mustaches in an elements tagname`, mustache.loc);\n\n      case 'beforeAttributeName':\n        addElementModifier(this.currentStartTag, mustache);\n        break;\n      case 'attributeName':\n      case 'afterAttributeName':\n        this.beginAttributeValue(false);\n        this.finishAttributeValue();\n        addElementModifier(this.currentStartTag, mustache);\n        tokenizer.transitionTo(BEFORE_ATTRIBUTE_NAME);\n        break;\n      case 'afterAttributeValueQuoted':\n        addElementModifier(this.currentStartTag, mustache);\n        tokenizer.transitionTo(BEFORE_ATTRIBUTE_NAME);\n        break;\n\n      // Attribute values\n      case 'beforeAttributeValue':\n        this.beginAttributeValue(false);\n        this.appendDynamicAttributeValuePart(mustache);\n        tokenizer.transitionTo(ATTRIBUTE_VALUE_UNQUOTED);\n        break;\n      case 'attributeValueDoubleQuoted':\n      case 'attributeValueSingleQuoted':\n      case 'attributeValueUnquoted':\n        this.appendDynamicAttributeValuePart(mustache);\n        break;\n\n      // TODO: Only append child when the tokenizer state makes\n      // sense to do so, otherwise throw an error.\n      default:\n        appendChild(this.currentElement(), mustache);\n    }\n\n    return mustache;\n  }\n\n  appendDynamicAttributeValuePart(part: ASTv1.MustacheStatement): void {\n    this.finalizeTextPart();\n    const attr = this.currentAttr;\n    attr.isDynamic = true;\n    attr.parts.push(part);\n  }\n\n  finalizeTextPart(): void {\n    const attr = this.currentAttr;\n    const text = attr.currentPart;\n    if (text !== null) {\n      this.currentAttr.parts.push(text);\n      this.startTextPart();\n    }\n  }\n\n  startTextPart(): void {\n    this.currentAttr.currentPart = null;\n  }\n\n  ContentStatement(content: HBS.ContentStatement): void {\n    updateTokenizerLocation(this.tokenizer, content);\n\n    this.tokenizer.tokenizePart(content.value);\n    this.tokenizer.flushData();\n  }\n\n  CommentStatement(rawComment: HBS.CommentStatement): Nullable<ASTv1.MustacheCommentStatement> {\n    const { tokenizer } = this;\n\n    if (tokenizer.state === 'comment') {\n      this.appendToCommentData(this.sourceForNode(rawComment));\n      return null;\n    }\n\n    const { value, loc } = rawComment;\n    const comment = b.mustacheComment({ value, loc: this.source.spanFor(loc) });\n\n    switch (tokenizer.state) {\n      case 'beforeAttributeName':\n      case 'afterAttributeName':\n        this.currentStartTag.comments.push(comment);\n        break;\n\n      case 'beforeData':\n      case 'data':\n        appendChild(this.currentElement(), comment);\n        break;\n\n      default:\n        throw generateSyntaxError(\n          `Using a Handlebars comment when in the \\`${tokenizer['state']}\\` state is not supported`,\n          this.source.spanFor(rawComment.loc)\n        );\n    }\n\n    return comment;\n  }\n\n  PartialStatement(partial: HBS.PartialStatement): never {\n    throw generateSyntaxError(\n      `Handlebars partials are not supported`,\n      this.source.spanFor(partial.loc)\n    );\n  }\n\n  PartialBlockStatement(partialBlock: HBS.PartialBlockStatement): never {\n    throw generateSyntaxError(\n      `Handlebars partial blocks are not supported`,\n      this.source.spanFor(partialBlock.loc)\n    );\n  }\n\n  Decorator(decorator: HBS.Decorator): never {\n    throw generateSyntaxError(\n      `Handlebars decorators are not supported`,\n      this.source.spanFor(decorator.loc)\n    );\n  }\n\n  DecoratorBlock(decoratorBlock: HBS.DecoratorBlock): never {\n    throw generateSyntaxError(\n      `Handlebars decorator blocks are not supported`,\n      this.source.spanFor(decoratorBlock.loc)\n    );\n  }\n\n  SubExpression(sexpr: HBS.SubExpression): ASTv1.SubExpression {\n    const { path, params, hash } = acceptCallNodes(this, sexpr);\n    return b.sexpr({ path, params, hash, loc: this.source.spanFor(sexpr.loc) });\n  }\n\n  PathExpression(path: HBS.PathExpression): ASTv1.PathExpression {\n    const { original } = path;\n    let parts: string[];\n\n    if (original.indexOf('/') !== -1) {\n      if (original.slice(0, 2) === './') {\n        throw generateSyntaxError(\n          `Using \"./\" is not supported in Glimmer and unnecessary`,\n          this.source.spanFor(path.loc)\n        );\n      }\n      if (original.slice(0, 3) === '../') {\n        throw generateSyntaxError(\n          `Changing context using \"../\" is not supported in Glimmer`,\n          this.source.spanFor(path.loc)\n        );\n      }\n      if (original.indexOf('.') !== -1) {\n        throw generateSyntaxError(\n          `Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths`,\n          this.source.spanFor(path.loc)\n        );\n      }\n      parts = [path.parts.join('/')];\n    } else if (original === '.') {\n      throw generateSyntaxError(\n        `'.' is not a supported path in Glimmer; check for a path with a trailing '.'`,\n        this.source.spanFor(path.loc)\n      );\n    } else {\n      parts = path.parts;\n    }\n\n    let thisHead = false;\n\n    // This is to fix a bug in the Handlebars AST where the path expressions in\n    // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)\n    // are simply turned into `{{foo}}`. The fix is to push it back onto the\n    // parts array and let the runtime see the difference. However, we cannot\n    // simply use the string `this` as it means literally the property called\n    // \"this\" in the current context (it can be expressed in the syntax as\n    // `{{[this]}}`, where the square bracket are generally for this kind of\n    // escaping â€“ such as `{{foo.[\"bar.baz\"]}}` would mean lookup a property\n    // named literally \"bar.baz\" on `this.foo`). By convention, we use `null`\n    // for this purpose.\n    if (/^this(?:\\..+)?$/u.test(original)) {\n      thisHead = true;\n    }\n\n    let pathHead: ASTv1.PathHead;\n    if (thisHead) {\n      pathHead = b.this({\n        loc: this.source.spanFor({\n          start: path.loc.start,\n          end: { line: path.loc.start.line, column: path.loc.start.column + 4 },\n        }),\n      });\n    } else if (path.data) {\n      const head = parts.shift();\n\n      if (head === undefined) {\n        throw generateSyntaxError(\n          `Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.`,\n          this.source.spanFor(path.loc)\n        );\n      }\n\n      pathHead = b.atName({\n        name: `@${head}`,\n        loc: this.source.spanFor({\n          start: path.loc.start,\n          end: { line: path.loc.start.line, column: path.loc.start.column + head.length + 1 },\n        }),\n      });\n    } else {\n      const head = parts.shift();\n\n      if (head === undefined) {\n        throw generateSyntaxError(\n          `Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.`,\n          this.source.spanFor(path.loc)\n        );\n      }\n\n      pathHead = b.var({\n        name: head,\n        loc: this.source.spanFor({\n          start: path.loc.start,\n          end: { line: path.loc.start.line, column: path.loc.start.column + head.length },\n        }),\n      });\n    }\n\n    return b.path({\n      head: pathHead,\n      tail: parts,\n      loc: this.source.spanFor(path.loc),\n    });\n  }\n\n  Hash(hash: HBS.Hash): ASTv1.Hash {\n    const pairs = hash.pairs.map((pair) =>\n      b.pair({\n        key: pair.key,\n        value: this.acceptNode<HBS.Expression['type']>(pair.value),\n        loc: this.source.spanFor(pair.loc),\n      })\n    );\n\n    return b.hash({ pairs, loc: this.source.spanFor(hash.loc) });\n  }\n\n  StringLiteral(string: HBS.StringLiteral): ASTv1.StringLiteral {\n    return b.literal({\n      type: 'StringLiteral',\n      value: string.value,\n      loc: this.source.spanFor(string.loc),\n    });\n  }\n\n  BooleanLiteral(boolean: HBS.BooleanLiteral): ASTv1.BooleanLiteral {\n    return b.literal({\n      type: 'BooleanLiteral',\n      value: boolean.value,\n      loc: this.source.spanFor(boolean.loc),\n    });\n  }\n\n  NumberLiteral(number: HBS.NumberLiteral): ASTv1.NumberLiteral {\n    return b.literal({\n      type: 'NumberLiteral',\n      value: number.value,\n      loc: this.source.spanFor(number.loc),\n    });\n  }\n\n  UndefinedLiteral(undef: HBS.UndefinedLiteral): ASTv1.UndefinedLiteral {\n    return b.literal({\n      type: 'UndefinedLiteral',\n      value: undefined,\n      loc: this.source.spanFor(undef.loc),\n    });\n  }\n\n  NullLiteral(nul: HBS.NullLiteral): ASTv1.NullLiteral {\n    return b.literal({\n      type: 'NullLiteral',\n      value: null,\n      loc: this.source.spanFor(nul.loc),\n    });\n  }\n}\n\nfunction calculateRightStrippedOffsets(original: string, value: string) {\n  if (value === '') {\n    // if it is empty, just return the count of newlines\n    // in original\n    return {\n      lines: original.split('\\n').length - 1,\n      columns: 0,\n    };\n  }\n\n  // otherwise, return the number of newlines prior to\n  // `value`\n  const [difference] = original.split(value) as [string];\n  const lines = difference.split(/\\n/u);\n  const lineCount = lines.length - 1;\n\n  return {\n    lines: lineCount,\n    columns: unwrap(lines[lineCount]).length,\n  };\n}\n\nfunction updateTokenizerLocation(tokenizer: Parser['tokenizer'], content: HBS.ContentStatement) {\n  let line = content.loc.start.line;\n  let column = content.loc.start.column;\n\n  const offsets = calculateRightStrippedOffsets(\n    content.original as Recast<HBS.StripFlags, string>,\n    content.value\n  );\n\n  line = line + offsets.lines;\n  if (offsets.lines) {\n    column = offsets.columns;\n  } else {\n    column = column + offsets.columns;\n  }\n\n  tokenizer.line = line;\n  tokenizer.column = column;\n}\n\nfunction acceptCallNodes(\n  compiler: HandlebarsNodeVisitors,\n  node: {\n    path:\n      | HBS.PathExpression\n      | HBS.SubExpression\n      | HBS.StringLiteral\n      | HBS.UndefinedLiteral\n      | HBS.NullLiteral\n      | HBS.NumberLiteral\n      | HBS.BooleanLiteral;\n    params: HBS.Expression[];\n    hash: HBS.Hash;\n  }\n): {\n  path: ASTv1.PathExpression | ASTv1.SubExpression;\n  params: ASTv1.Expression[];\n  hash: ASTv1.Hash;\n} {\n  let path: ASTv1.PathExpression | ASTv1.SubExpression;\n\n  switch (node.path.type) {\n    case 'PathExpression':\n      path = compiler.PathExpression(node.path);\n      break;\n\n    case 'SubExpression':\n      path = compiler.SubExpression(node.path);\n      break;\n\n    case 'StringLiteral':\n    case 'UndefinedLiteral':\n    case 'NullLiteral':\n    case 'NumberLiteral':\n    case 'BooleanLiteral': {\n      let value: string;\n      if (node.path.type === 'BooleanLiteral') {\n        value = node.path.original.toString();\n      } else if (node.path.type === 'StringLiteral') {\n        value = `\"${node.path.original}\"`;\n      } else if (node.path.type === 'NullLiteral') {\n        value = 'null';\n      } else if (node.path.type === 'NumberLiteral') {\n        value = node.path.value.toString();\n      } else {\n        value = 'undefined';\n      }\n      throw generateSyntaxError(\n        `${node.path.type} \"${\n          node.path.type === 'StringLiteral' ? node.path.original : value\n        }\" cannot be called as a sub-expression, replace (${value}) with ${value}`,\n        compiler.source.spanFor(node.path.loc)\n      );\n    }\n  }\n\n  const params = node.params\n    ? node.params.map((e) => compiler.acceptNode<HBS.Expression['type']>(e))\n    : [];\n\n  // if there is no hash, position it as a collapsed node immediately after the last param (or the\n  // path, if there are also no params)\n  const end = isPresentArray(params) ? getLast(params).loc : path.loc;\n\n  const hash = node.hash\n    ? compiler.Hash(node.hash)\n    : b.hash({\n        pairs: [],\n        loc: compiler.source.spanFor(end).collapse('end'),\n      });\n\n  return { path, params, hash };\n}\n\nfunction addElementModifier(\n  element: ParserNodeBuilder<StartTag>,\n  mustache: ASTv1.MustacheStatement\n) {\n  const { path, params, hash, loc } = mustache;\n\n  if (isHBSLiteral(path)) {\n    const modifier = `{{${printLiteral(path)}}}`;\n    const tag = `<${element.name} ... ${modifier} ...`;\n\n    throw generateSyntaxError(`In ${tag}, ${modifier} is not a valid modifier`, mustache.loc);\n  }\n\n  const modifier = b.elementModifier({ path, params, hash, loc });\n  element.modifiers.push(modifier);\n}\n","/// FreeVarNamespace ///\n\nexport type HELPER_VAR_NS = 'Helper';\nexport const HELPER_VAR_NS: HELPER_VAR_NS = 'Helper';\nexport type MODIFIER_VAR_NS = 'Modifier';\nexport const MODIFIER_VAR_NS: MODIFIER_VAR_NS = 'Modifier';\nexport type COMPONENT_VAR_NS = 'Component';\nexport const COMPONENT_VAR_NS: COMPONENT_VAR_NS = 'Component';\n\nexport type FreeVarNamespace = HELPER_VAR_NS | MODIFIER_VAR_NS | COMPONENT_VAR_NS;\n","/**\n * A free variable is resolved according to a resolution rule:\n *\n * 1. Strict resolution\n * 2. Namespaced resolution\n */\n\nimport type { GetContextualFreeOpcode } from '@glimmer/interfaces';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { FreeVarNamespace } from './constants';\n\nimport { COMPONENT_VAR_NS, HELPER_VAR_NS, MODIFIER_VAR_NS } from './constants';\n\n/**\n * Strict resolution is used:\n *\n * 1. in a strict mode template\n * 2. in an local variable invocation with dot paths\n */\nexport const STRICT_RESOLUTION = {\n  resolution: (): GetContextualFreeOpcode => SexpOpcodes.GetStrictKeyword,\n  serialize: (): SerializedResolution => 'Strict',\n  isAngleBracket: false as const,\n};\n\nexport type StrictResolution = typeof STRICT_RESOLUTION;\n\nexport const HTML_RESOLUTION = {\n  ...STRICT_RESOLUTION,\n  isAngleBracket: true as const,\n};\n\nexport type HtmlResolution = typeof HTML_RESOLUTION;\n\nexport function isStrictResolution(value: unknown): value is StrictResolution {\n  return value === STRICT_RESOLUTION;\n}\n\n/**\n * A `LooseModeResolution` includes one or more namespaces to resolve the variable in\n *\n * In practice, there are a limited number of possible combinations of these degrees of freedom,\n * and they are captured by the `Namespaces` union below.\n */\nexport class LooseModeResolution {\n  /**\n   * Namespaced resolution is used in an unambiguous syntax position:\n   *\n   * 1. `(sexp)` (namespace: `Helper`)\n   * 2. `{{#block}}` (namespace: `Component`)\n   * 3. `<a {{modifier}}>` (namespace: `Modifier`)\n   * 4. `<Component />` (namespace: `Component`)\n   */\n  static namespaced(namespace: FreeVarNamespace, isAngleBracket = false): LooseModeResolution {\n    return new LooseModeResolution([namespace], isAngleBracket);\n  }\n\n  /**\n   * Append resolution is used when the variable should be resolved in both the `component` and\n   * `helper` namespaces.\n   *\n   * ```hbs\n   * {{x}}\n   * ```\n   *\n   * ```hbs\n   * {{x y}}\n   * ```\n   *\n   * ^ In either case, `x` should be resolved in the `component` and `helper` namespaces.\n   */\n  static append(): LooseModeResolution {\n    return new LooseModeResolution([COMPONENT_VAR_NS, HELPER_VAR_NS]);\n  }\n\n  /**\n   * Trusting append resolution is used when the variable should be resolved only in the\n   * `helper` namespaces.\n   *\n   * ```hbs\n   * {{{x}}}\n   * ```\n   *\n   * ```hbs\n   * {{{x y}}}\n   * ```\n   *\n   * ^ In either case, `x` should be resolved in the `helper` namespace.\n   */\n  static trustingAppend(): LooseModeResolution {\n    return this.namespaced(HELPER_VAR_NS);\n  }\n\n  constructor(\n    readonly namespaces: Namespaces,\n    readonly isAngleBracket = false\n  ) {}\n\n  resolution(): GetContextualFreeOpcode {\n    if (this.namespaces.length === 1) {\n      switch (this.namespaces[0]) {\n        case HELPER_VAR_NS:\n          return SexpOpcodes.GetFreeAsHelperHead;\n        case MODIFIER_VAR_NS:\n          return SexpOpcodes.GetFreeAsModifierHead;\n        case COMPONENT_VAR_NS:\n          return SexpOpcodes.GetFreeAsComponentHead;\n      }\n    } else {\n      return SexpOpcodes.GetFreeAsComponentOrHelperHead;\n    }\n  }\n\n  serialize(): SerializedResolution {\n    if (this.namespaces.length === 1) {\n      return this.namespaces[0];\n    } else {\n      return 'ComponentOrHelper';\n    }\n  }\n}\n\nexport const HELPER_NAMESPACE = HELPER_VAR_NS;\nexport const MODIFIER_NAMESPACE = MODIFIER_VAR_NS;\nexport const COMPONENT_NAMESPACE = COMPONENT_VAR_NS;\n\n/**\n * A `Namespaced` must be resolved in one or more namespaces.\n *\n * ```hbs\n * <X />\n * ```\n *\n * ^ `X` is resolved in the `component` namespace\n *\n * ```hbs\n * (x)\n * ```\n *\n * ^ `x` is resolved in the `helper` namespace\n *\n * ```hbs\n * <a {{x}} />\n * ```\n *\n * ^ `x` is resolved in the `modifier` namespace\n */\ntype Namespaces =\n  | [HELPER_VAR_NS]\n  | [MODIFIER_VAR_NS]\n  | [COMPONENT_VAR_NS]\n  | [COMPONENT_VAR_NS, HELPER_VAR_NS];\n\nexport type FreeVarResolution = StrictResolution | HtmlResolution | LooseModeResolution;\n\n// Serialization\nexport type SerializedResolution =\n  | 'Strict'\n  | 'Helper'\n  | 'Modifier'\n  | 'Component'\n  | 'ComponentOrHelper';\n\nexport function loadResolution(resolution: SerializedResolution): FreeVarResolution {\n  if (resolution === 'Strict') {\n    return STRICT_RESOLUTION;\n  } else if (resolution === 'ComponentOrHelper') {\n    return LooseModeResolution.append();\n  } else {\n    return LooseModeResolution.namespaced(resolution as FreeVarNamespace);\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}