import{assertNever as t,assign as e,dict as s}from"@glimmer/util";import{parseWithoutProcessing as r,parse as n}from"@handlebars/parser";import{EventedTokenizer as a,EntityParser as i,HTML5NamedCharRefs as o}from"simple-html-tokenizer";import{SexpOpcodes as l}from"@glimmer/wire-format";const c=/["&\xA0]/u,h=new RegExp(c.source,"gu"),u=/[&<>\xA0]/u,p=new RegExp(u.source,"gu");function d(t){switch(t.charCodeAt(0)){case 160:return"&nbsp;";case 34:return"&quot;";case 38:return"&amp;";default:return t}}function m(t){switch(t.charCodeAt(0)){case 160:return"&nbsp;";case 38:return"&amp;";case 60:return"&lt;";case 62:return"&gt;";default:return t}}function f(t,e){return t.loc.isInvisible||e.loc.isInvisible?0:t.loc.startPosition.line<e.loc.startPosition.line||t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column<e.loc.startPosition.column?-1:t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column===e.loc.startPosition.column?0:1}const g=new Set(["area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"]);function b(){return[...g]}const k=/^\S/u;function w(t){return g.has(t.toLowerCase())&&t[0]?.toLowerCase()===t[0]}class y{buffer="";options;constructor(t){this.options=t}handledByOverride(t,e=!1){if(void 0!==this.options.override){let s=this.options.override(t,this.options);if("string"==typeof s)return e&&k.test(s)&&(s=` ${s}`),this.buffer+=s,!0}return!1}Node(t){switch(t.type){case"MustacheStatement":case"BlockStatement":case"MustacheCommentStatement":case"CommentStatement":case"TextNode":case"ElementNode":case"AttrNode":case"Block":case"Template":return this.TopLevelStatement(t);case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":case"PathExpression":case"SubExpression":return this.Expression(t);case"ConcatStatement":return this.ConcatStatement(t);case"Hash":return this.Hash(t);case"HashPair":return this.HashPair(t);case"ElementModifierStatement":return this.ElementModifierStatement(t)}}Expression(t){switch(t.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return this.Literal(t);case"PathExpression":return this.PathExpression(t);case"SubExpression":return this.SubExpression(t)}}Literal(t){switch(t.type){case"StringLiteral":return this.StringLiteral(t);case"BooleanLiteral":return this.BooleanLiteral(t);case"NumberLiteral":return this.NumberLiteral(t);case"UndefinedLiteral":return this.UndefinedLiteral(t);case"NullLiteral":return this.NullLiteral(t)}}TopLevelStatement(t){switch(t.type){case"MustacheStatement":return this.MustacheStatement(t);case"BlockStatement":return this.BlockStatement(t);case"MustacheCommentStatement":return this.MustacheCommentStatement(t);case"CommentStatement":return this.CommentStatement(t);case"TextNode":return this.TextNode(t);case"ElementNode":return this.ElementNode(t);case"Block":return this.Block(t);case"Template":return this.Template(t);case"AttrNode":return this.AttrNode(t)}}Template(t){this.TopLevelStatements(t.body)}Block(t){t.chained&&(t.body[0].chained=!0),this.handledByOverride(t)||this.TopLevelStatements(t.body)}TopLevelStatements(t){t.forEach((t=>this.TopLevelStatement(t)))}ElementNode(t){this.handledByOverride(t)||(this.OpenElementNode(t),this.TopLevelStatements(t.children),this.CloseElementNode(t))}OpenElementNode(t){this.buffer+=`<${t.tag}`;const e=[...t.attributes,...t.modifiers,...t.comments].sort(f);for(const t of e)switch(this.buffer+=" ",t.type){case"AttrNode":this.AttrNode(t);break;case"ElementModifierStatement":this.ElementModifierStatement(t);break;case"MustacheCommentStatement":this.MustacheCommentStatement(t)}t.blockParams.length&&this.BlockParams(t.blockParams),t.selfClosing&&(this.buffer+=" /"),this.buffer+=">"}CloseElementNode(t){t.selfClosing||w(t.tag)||(this.buffer+=`</${t.tag}>`)}AttrNode(t){if(this.handledByOverride(t))return;let{name:e,value:s}=t;this.buffer+=e,("TextNode"!==s.type||s.chars.length>0)&&(this.buffer+="=",this.AttrNodeValue(s))}AttrNodeValue(t){"TextNode"===t.type?(this.buffer+='"',this.TextNode(t,!0),this.buffer+='"'):this.Node(t)}TextNode(t,e){var s;this.handledByOverride(t)||("raw"===this.options.entityEncoding?this.buffer+=t.chars:this.buffer+=e?(s=t.chars,c.test(s)?s.replace(h,d):s):function(t){return u.test(t)?t.replace(p,m):t}(t.chars))}MustacheStatement(t){this.handledByOverride(t)||(this.buffer+=t.trusting?"{{{":"{{",t.strip.open&&(this.buffer+="~"),this.Expression(t.path),this.Params(t.params),this.Hash(t.hash),t.strip.close&&(this.buffer+="~"),this.buffer+=t.trusting?"}}}":"}}")}BlockStatement(t){this.handledByOverride(t)||(t.chained?(this.buffer+=t.inverseStrip.open?"{{~":"{{",this.buffer+="else "):this.buffer+=t.openStrip.open?"{{~#":"{{#",this.Expression(t.path),this.Params(t.params),this.Hash(t.hash),t.program.blockParams.length&&this.BlockParams(t.program.blockParams),t.chained?this.buffer+=t.inverseStrip.close?"~}}":"}}":this.buffer+=t.openStrip.close?"~}}":"}}",this.Block(t.program),t.inverse&&(t.inverse.chained||(this.buffer+=t.inverseStrip.open?"{{~":"{{",this.buffer+="else",this.buffer+=t.inverseStrip.close?"~}}":"}}"),this.Block(t.inverse)),t.chained||(this.buffer+=t.closeStrip.open?"{{~/":"{{/",this.Expression(t.path),this.buffer+=t.closeStrip.close?"~}}":"}}"))}BlockParams(t){this.buffer+=` as |${t.join(" ")}|`}ConcatStatement(t){this.handledByOverride(t)||(this.buffer+='"',t.parts.forEach((t=>{"TextNode"===t.type?this.TextNode(t,!0):this.Node(t)})),this.buffer+='"')}MustacheCommentStatement(t){this.handledByOverride(t)||(this.buffer+=`{{!--${t.value}--}}`)}ElementModifierStatement(t){this.handledByOverride(t)||(this.buffer+="{{",this.Expression(t.path),this.Params(t.params),this.Hash(t.hash),this.buffer+="}}")}CommentStatement(t){this.handledByOverride(t)||(this.buffer+=`\x3c!--${t.value}--\x3e`)}PathExpression(t){this.handledByOverride(t)||(this.buffer+=t.original)}SubExpression(t){this.handledByOverride(t)||(this.buffer+="(",this.Expression(t.path),this.Params(t.params),this.Hash(t.hash),this.buffer+=")")}Params(t){t.length&&t.forEach((t=>{this.buffer+=" ",this.Expression(t)}))}Hash(t){this.handledByOverride(t,!0)||t.pairs.forEach((t=>{this.buffer+=" ",this.HashPair(t)}))}HashPair(t){this.handledByOverride(t)||(this.buffer+=t.key,this.buffer+="=",this.Node(t.value))}StringLiteral(t){this.handledByOverride(t)||(this.buffer+=JSON.stringify(t.value))}BooleanLiteral(t){this.handledByOverride(t)||(this.buffer+=t.value)}NumberLiteral(t){this.handledByOverride(t)||(this.buffer+=t.value)}UndefinedLiteral(t){this.handledByOverride(t)||(this.buffer+="undefined")}NullLiteral(t){this.handledByOverride(t)||(this.buffer+="null")}print(t){let{options:e}=this;if(e.override){let s=e.override(t,e);if(void 0!==s)return s}return this.buffer="",this.Node(t),this.buffer}}function v(t,e={entityEncoding:"transformed"}){return t?new y(e).print(t):""}function S(t,e){return t in x&&(void 0===e||x[t].includes(e))}const x={action:["Call","Modifier"],component:["Call","Append","Block"],debugger:["Append"],"each-in":["Block"],each:["Block"],"has-block-params":["Call","Append"],"has-block":["Call","Append"],helper:["Call","Append"],if:["Call","Append","Block"],"in-element":["Block"],let:["Block"],log:["Call","Append"],modifier:["Call","Modifier"],mount:["Append"],mut:["Call","Append"],outlet:["Append"],readonly:["Call","Append"],unbound:["Call","Append"],unless:["Call","Append","Block"],yield:["Append"]};function P(t){return t.length>0}function E(t,e="unexpected empty list"){return t}function N(t){return 0===t.length?void 0:t[t.length-1]}function C(t){return 0===t.length?void 0:t[0]}const A=Object.freeze({line:1,column:0}),T=Object.freeze({source:"(synthetic)",start:A,end:A}),B=Object.freeze({source:"(nonexistent)",start:A,end:A}),L=Object.freeze({source:"(broken)",start:A,end:A}),O="CharPosition",H="HbsPosition",F="InternalsSynthetic",$="NonExistent",z="Broken",M="MATCH_ANY",I="IS_INVISIBLE";class _{_whens;constructor(t){this._whens=t}first(t){for(const e of this._whens){const s=e.match(t);if(P(s))return s[0]}return null}}class U{_map=new Map;get(t,e){let s=this._map.get(t);return s||(s=e(),this._map.set(t,s),s)}add(t,e){this._map.set(t,e)}match(t){const e=function(t){switch(t){case z:case F:case $:return I;default:return t}}(t),s=[],r=this._map.get(e),n=this._map.get(M);return r&&s.push(r),n&&s.push(n),s}}function V(t){return t(new D).validate()}class D{_whens=new U;validate(){return(t,e)=>this.matchFor(t.kind,e.kind)(t,e)}matchFor(t,e){const s=this._whens.match(t);return P(s),new _(s).first(e)}when(t,e,s){return this._whens.get(t,(()=>new U)).add(e,s),this}}class j{static synthetic(t){let e=K.synthetic(t);return new j({loc:e,chars:t})}static load(t,e){return new j({loc:K.load(t,e[1]),chars:e[0]})}chars;loc;constructor(t){this.loc=t.loc,this.chars=t.chars}getString(){return this.chars}serialize(){return[this.chars,this.loc.serialize()]}}class K{static get NON_EXISTENT(){return new G($,B).wrap()}static load(e,s){return"number"==typeof s?K.forCharPositions(e,s,s):"string"==typeof s?K.synthetic(s):Array.isArray(s)?K.forCharPositions(e,s[0],s[1]):s===$?K.NON_EXISTENT:s===z?K.broken(L):void t(s)}static forHbsLoc(t,e){const s=new X(t,e.start),r=new X(t,e.end);return new R(t,{start:s,end:r},e).wrap()}static forCharPositions(t,e,s){const r=new Q(t,e),n=new Q(t,s);return new J(t,{start:r,end:n}).wrap()}static synthetic(t){return new G(F,B,t).wrap()}static broken(t=L){return new G(z,t).wrap()}isInvisible;constructor(t){var e;this.data=t,this.isInvisible=(e=t.kind)!==O&&e!==H}getStart(){return this.data.getStart().wrap()}getEnd(){return this.data.getEnd().wrap()}get loc(){const t=this.data.toHbsSpan();return null===t?L:t.toHbsLoc()}get module(){return this.data.getModule()}get startPosition(){return this.loc.start}get endPosition(){return this.loc.end}toJSON(){return this.loc}withStart(t){return Y(t.data,this.data.getEnd())}withEnd(t){return Y(this.data.getStart(),t.data)}asString(){return this.data.asString()}toSlice(t){const e=this.data.asString();return new j({loc:this,chars:t||e})}get start(){return this.loc.start}set start(t){this.data.locDidUpdate({start:t})}get end(){return this.loc.end}set end(t){this.data.locDidUpdate({end:t})}get source(){return this.module}collapse(t){switch(t){case"start":return this.getStart().collapsed();case"end":return this.getEnd().collapsed()}}extend(t){return Y(this.data.getStart(),t.data.getEnd())}serialize(){return this.data.serialize()}slice({skipStart:t=0,skipEnd:e=0}){return Y(this.getStart().move(t).data,this.getEnd().move(-e).data)}sliceStartChars({skipStart:t=0,chars:e}){return Y(this.getStart().move(t).data,this.getStart().move(t+e).data)}sliceEndChars({skipEnd:t=0,chars:e}){return Y(this.getEnd().move(t-e).data,this.getStart().move(-t).data)}}class J{kind=O;#t=null;constructor(t,e){this.source=t,this.charPositions=e}wrap(){return new K(this)}asString(){return this.source.slice(this.charPositions.start.charPos,this.charPositions.end.charPos)}getModule(){return this.source.module}getStart(){return this.charPositions.start}getEnd(){return this.charPositions.end}locDidUpdate(){}toHbsSpan(){let t=this.#t;if(null===t){const e=this.charPositions.start.toHbsPos(),s=this.charPositions.end.toHbsPos();t=this.#t=null===e||null===s?W:new R(this.source,{start:e,end:s})}return t===W?null:t}serialize(){const{start:{charPos:t},end:{charPos:e}}=this.charPositions;return t===e?t:[t,e]}toCharPosSpan(){return this}}class R{kind=H;#e=null;#s;constructor(t,e,s=null){this.source=t,this.hbsPositions=e,this.#s=s}serialize(){const t=this.toCharPosSpan();return null===t?z:t.wrap().serialize()}wrap(){return new K(this)}updateProvided(t,e){this.#s&&(this.#s[e]=t),this.#e=null,this.#s={start:t,end:t}}locDidUpdate({start:t,end:e}){void 0!==t&&(this.updateProvided(t,"start"),this.hbsPositions.start=new X(this.source,t,null)),void 0!==e&&(this.updateProvided(e,"end"),this.hbsPositions.end=new X(this.source,e,null))}asString(){const t=this.toCharPosSpan();return null===t?"":t.asString()}getModule(){return this.source.module}getStart(){return this.hbsPositions.start}getEnd(){return this.hbsPositions.end}toHbsLoc(){return{start:this.hbsPositions.start.hbsPos,end:this.hbsPositions.end.hbsPos}}toHbsSpan(){return this}toCharPosSpan(){let t=this.#e;if(null===t){const e=this.hbsPositions.start.toCharPos(),s=this.hbsPositions.end.toCharPos();if(!e||!s)return t=this.#e=W,null;t=this.#e=new J(this.source,{start:e,end:s})}return t===W?null:t}}class G{constructor(t,e,s=null){this.kind=t,this.loc=e,this.string=s}serialize(){switch(this.kind){case z:case $:return this.kind;case F:return this.string||""}}wrap(){return new K(this)}asString(){return this.string||""}locDidUpdate({start:t,end:e}){void 0!==t&&(this.loc.start=t),void 0!==e&&(this.loc.end=e)}getModule(){return"an unknown module"}getStart(){return new Z(this.kind,this.loc.start)}getEnd(){return new Z(this.kind,this.loc.end)}toCharPosSpan(){return this}toHbsSpan(){return null}toHbsLoc(){return L}}const Y=V((t=>t.when(H,H,((t,e)=>new R(t.source,{start:t,end:e}).wrap())).when(O,O,((t,e)=>new J(t.source,{start:t,end:e}).wrap())).when(O,H,((t,e)=>{const s=e.toCharPos();return null===s?new G(z,L).wrap():Y(t,s)})).when(H,O,((t,e)=>{const s=t.toCharPos();return null===s?new G(z,L).wrap():Y(s,e)})).when(I,M,(t=>new G(t.kind,L).wrap())).when(M,I,((t,e)=>new G(e.kind,L).wrap())))),W="BROKEN";class q{static forHbsPos(t,e){return new X(t,e,null).wrap()}static broken(t=A){return new Z(z,t).wrap()}constructor(t){this.data=t}get offset(){const t=this.data.toCharPos();return null===t?null:t.offset}eql(t){return tt(this.data,t.data)}until(t){return Y(this.data,t.data)}move(t){const e=this.data.toCharPos();if(null===e)return q.broken();{const s=e.offset+t;return e.source.validate(s)?new Q(e.source,s).wrap():q.broken()}}collapsed(){return Y(this.data,this.data)}toJSON(){return this.data.toJSON()}}class Q{kind=O;_locPos=null;constructor(t,e){this.source=t,this.charPos=e}toCharPos(){return this}toJSON(){const t=this.toHbsPos();return null===t?A:t.toJSON()}wrap(){return new q(this)}get offset(){return this.charPos}toHbsPos(){let t=this._locPos;if(null===t){const e=this.source.hbsPosFor(this.charPos);this._locPos=t=null===e?W:new X(this.source,e,this.charPos)}return t===W?null:t}}class X{kind=H;_charPos;constructor(t,e,s=null){this.source=t,this.hbsPos=e,this._charPos=null===s?null:new Q(t,s)}toCharPos(){let t=this._charPos;if(null===t){const e=this.source.charPosFor(this.hbsPos);this._charPos=t=null===e?W:new Q(this.source,e)}return t===W?null:t}toJSON(){return this.hbsPos}wrap(){return new q(this)}toHbsPos(){return this}}class Z{constructor(t,e){this.kind=t,this.pos=e}toCharPos(){return null}toJSON(){return this.pos}wrap(){return new q(this)}get offset(){return null}}const tt=V((t=>t.when(H,H,(({hbsPos:t},{hbsPos:e})=>t.column===e.column&&t.line===e.line)).when(O,O,(({charPos:t},{charPos:e})=>t===e)).when(O,H,(({offset:t},e)=>t===e.toCharPos()?.offset)).when(H,O,((t,{offset:e})=>t.toCharPos()?.offset===e)).when(M,M,(()=>!1))));class et{static from(t,e={}){return new et(t,e.meta?.moduleName)}constructor(t,e="an unknown module"){this.source=t,this.module=e}validate(t){return t>=0&&t<=this.source.length}slice(t,e){return this.source.slice(t,e)}offsetFor(t,e){return q.forHbsPos(this,{line:t,column:e})}spanFor({start:t,end:e}){return K.forHbsLoc(this,{start:{line:t.line,column:t.column},end:{line:e.line,column:e.column}})}hbsPosFor(t){let e=0,s=0;if(t>this.source.length)return null;for(;;){let r=this.source.indexOf("\n",s);if(t<=r||-1===r)return{line:e+1,column:t-s};e+=1,s=r+1}}charPosFor(t){let{line:e,column:s}=t,r=this.source.length,n=0,a=0;for(;a<r;){let t=this.source.indexOf("\n",a);if(-1===t&&(t=this.source.length),n===e-1)return a+s>t?t:a+s;if(-1===t)return 0;n+=1,a=t+1}return r}}class st{static range(t,e=K.NON_EXISTENT){return new st(t.map(rt)).getRangeOffset(e)}_span;constructor(t=[]){this._span=t}add(t){this._span.push(t)}getRangeOffset(t){if(P(this._span)){let t=C(this._span),e=N(this._span);return t.extend(e)}return t}}function rt(t){if(Array.isArray(t)){let e=C(t),s=N(t);return rt(e).extend(rt(s))}return t instanceof K?t:t.loc}function nt(t){return!Array.isArray(t)||0!==t.length}function at(t,e){return nt(t)?rt(t):e}var it=Object.freeze({__proto__:null,NON_EXISTENT_LOCATION:B,SYNTHETIC_LOCATION:T,Source:et,SourceOffset:q,SourceSlice:j,SourceSpan:K,SpanList:st,UNKNOWN_POSITION:A,hasSpan:nt,loc:rt,maybeLoc:at});function ot(t,e){let{module:s,loc:r}=e,{line:n,column:a}=r.start,i=e.asString(),o=i?`\n\n|\n|  ${i.split("\n").join("\n|  ")}\n|\n\n`:"",l=new Error(`${t}: ${o}(error occurred in '${s}' @ line ${n} : column ${a})`);return l.name="SyntaxError",l.location=e,l.code=i,l}const lt={Template:["body"],Block:["body"],MustacheStatement:["path","params","hash"],BlockStatement:["path","params","hash","program","inverse"],ElementModifierStatement:["path","params","hash"],CommentStatement:[],MustacheCommentStatement:[],ElementNode:["attributes","modifiers","children","comments"],AttrNode:["value"],TextNode:[],ConcatStatement:["parts"],SubExpression:["path","params","hash"],PathExpression:[],StringLiteral:[],BooleanLiteral:[],NumberLiteral:[],NullLiteral:[],UndefinedLiteral:[],Hash:["pairs"],HashPair:["value"]},ct=function(){function t(t,e,s,r){let n=Error.call(this,t);this.key=r,this.message=t,this.node=e,this.parent=s,n.stack&&(this.stack=n.stack)}return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}();function ht(t,e,s){return new ct("Cannot remove a node unless it is part of an array",t,e,s)}function ut(t,e,s){return new ct("Cannot replace a node with multiple nodes unless it is part of an array",t,e,s)}function pt(t,e){return new ct("Replacing and removing in key handlers is not yet supported.",t,null,e)}class dt{node;parent;parentKey;constructor(t,e=null,s=null){this.node=t,this.parent=e,this.parentKey=s}get parentNode(){return this.parent?this.parent.node:null}parents(){return{[Symbol.iterator]:()=>new mt(this)}}}class mt{path;constructor(t){this.path=t}next(){return this.path.parent?(this.path=this.path.parent,{done:!1,value:this.path}):{done:!0,value:null}}}function ft(t){return"function"==typeof t?t:t.enter}function gt(t){return"function"==typeof t?void 0:t.exit}function bt(t,e){let s,r,n,{node:a,parent:i,parentKey:o}=e,l=function(t,e){if(t.Program&&("Template"===e&&!t.Template||"Block"===e&&!t.Block))return t.Program;let s=t[e];return void 0!==s?s:t.All}(t,a.type);if(void 0!==l&&(s=ft(l),r=gt(l)),void 0!==s&&(n=s(a,e)),null!=n){if(JSON.stringify(a)!==JSON.stringify(n))return Array.isArray(n)?(yt(t,n,i,o),n):bt(t,new dt(n,i,o))||n;n=void 0}if(void 0===n){let s=lt[a.type];for(let r=0;r<s.length;r++)wt(t,l,e,s[r]);void 0!==r&&(n=r(a,e))}return n}function kt(t,e,s){t[e]=s}function wt(t,e,s,r){let n,a,{node:i}=s,o=function(t,e){return t[e]}(i,r);if(o){if(void 0!==e){let t=function(t,e){let s="function"!=typeof t?t.keys:void 0;if(void 0===s)return;let r=s[e];return void 0!==r?r:s.All}(e,r);void 0!==t&&(n=ft(t),a=gt(t))}if(void 0!==n&&void 0!==n(i,r))throw pt(i,r);if(Array.isArray(o))yt(t,o,s,r);else{let e=bt(t,new dt(o,s,r));void 0!==e&&function(t,e,s,r){if(null===r)throw ht(s,t,e);if(Array.isArray(r)){if(1!==r.length)throw 0===r.length?ht(s,t,e):ut(s,t,e);kt(t,e,r[0])}else kt(t,e,r)}(i,r,o,e)}if(void 0!==a&&void 0!==a(i,r))throw pt(i,r)}}function yt(t,e,s,r){for(let n=0;n<e.length;n++){let a=e[n],i=bt(t,new dt(a,s,r));void 0!==i&&(n+=vt(e,n,i)-1)}}function vt(t,e,s){return null===s?(t.splice(e,1),0):Array.isArray(s)?(t.splice(e,1,...s),s.length):(t.splice(e,1,s),1)}function St(t,e){bt(e,new dt(t))}class xt{stack=[];constructor(t){this.order=t}visit(t,e){t&&(this.stack.push(t),"post"===this.order?(this.children(t,e),e(t,this)):(e(t,this),this.children(t,e)),this.stack.pop())}children(t,e){switch(t.type){case"Block":case"Template":return void Pt(this,t.body,e);case"ElementNode":return void Pt(this,t.children,e);case"BlockStatement":return this.visit(t.program,e),void this.visit(t.inverse||null,e);default:return}}}function Pt(t,e,s){for(const r of e)t.visit(r,s)}function Et(t,e){(function(t){switch(t.type){case"Block":case"Template":return t.body;case"ElementNode":return t.children}})(t).push(e)}function Nt(t){return"StringLiteral"===t.type||"BooleanLiteral"===t.type||"NumberLiteral"===t.type||"NullLiteral"===t.type||"UndefinedLiteral"===t.type}let Ct;function At(){return Ct||(Ct=new et("","(synthetic)")),Ct}function Tt(t,e){return Ut.var({name:t,loc:zt(e||null)})}function Bt(t,e){let s=zt(e||null);if("string"!=typeof t){if("type"in t)return t;{t.head.indexOf(".");let{head:r,tail:n}=t;return Ut.path({head:Ut.head({original:r,loc:s.sliceStartChars({chars:r.length})}),tail:n,loc:zt(e||null)})}}let{head:r,tail:n}=function(t,e){let[s,...r]=E(t.split(".")),n=Ut.head({original:s,loc:zt(e||null)});return Ut.path({head:n,tail:r,loc:zt(e||null)})}(t,s);return Ut.path({head:r,tail:n,loc:s})}function Lt(t,e,s){return Ut.literal({type:t,value:e,loc:zt(s||null)})}function Ot(t=[],e){return Ut.hash({pairs:t,loc:zt(e||null)})}function Ht(t){return t.map((t=>"string"==typeof t?Ut.var({name:t,loc:K.synthetic(t)}):t))}function Ft(t=[],e=[],s=!1,r){return Ut.blockItself({body:t,params:Ht(e),chained:s,loc:zt(r||null)})}function $t(t=[],e=[],s){return Ut.template({body:t,blockParams:e,loc:zt(s||null)})}function zt(...t){if(1===t.length){let e=t[0];return e&&"object"==typeof e?K.forHbsLoc(At(),e):K.forHbsLoc(At(),T)}{let[e,s,r,n,a]=t,i=a?new et("",a):At();return K.forHbsLoc(i,{start:{line:e,column:s},end:{line:r||e,column:n||s}})}}var Mt={mustache:function(t,e=[],s=Ot([]),r=!1,n,a){return Ut.mustache({path:Bt(t),params:e,hash:s,trusting:r,strip:a,loc:zt(n||null)})},block:function(t,e,s,r,n=null,a,i,o,l){let c,h=null;return c="Template"===r.type?Ut.blockItself({params:Ht(r.blockParams),body:r.body,loc:r.loc}):r,"Template"===n?.type?(n.blockParams.length,h=Ut.blockItself({params:[],body:n.body,loc:n.loc})):h=n,Ut.block({path:Bt(t),params:e||[],hash:s||Ot([]),defaultBlock:c,elseBlock:h,loc:zt(a||null),openStrip:i,inverseStrip:o,closeStrip:l})},comment:function(t,e){return Ut.comment({value:t,loc:zt(e||null)})},mustacheComment:function(t,e){return Ut.mustacheComment({value:t,loc:zt(e||null)})},element:function(t,e={}){let s,r,{attrs:n,blockParams:a,modifiers:i,comments:o,children:l,openTag:c,closeTag:h,loc:u}=e;"string"==typeof t?t.endsWith("/")?(s=Bt(t.slice(0,-1)),r=!0):s=Bt(t):"type"in t?(t.type,t.type,s=t):"path"in t?(t.path.type,t.path.type,s=t.path,r=t.selfClosing):(s=Bt(t.name),r=t.selfClosing);let p=a?.map((t=>"string"==typeof t?Tt(t):t)),d=null;return h?d=zt(h||null):void 0===h&&(d=r||w(s.original)?null:zt(null)),Ut.element({path:s,selfClosing:r||!1,attributes:n||[],params:p||[],modifiers:i||[],comments:o||[],children:l||[],openTag:zt(c||null),closeTag:d,loc:zt(u||null)})},elementModifier:function(t,e,s,r){return Ut.elementModifier({path:Bt(t),params:e||[],hash:s||Ot([]),loc:zt(r||null)})},attr:function(t,e,s){return Ut.attr({name:t,value:e,loc:zt(s||null)})},text:function(t="",e){return Ut.text({chars:t,loc:zt(e||null)})},sexpr:function(t,e=[],s=Ot([]),r){return Ut.sexpr({path:Bt(t),params:e,hash:s,loc:zt(r||null)})},concat:function(t,e){if(!P(t))throw new Error("b.concat requires at least one part");return Ut.concat({parts:t,loc:zt(e||null)})},hash:Ot,pair:function(t,e,s){return Ut.pair({key:t,value:e,loc:zt(s||null)})},literal:Lt,program:function(t,e,s){return e&&e.length?Ft(t,e,!1,s):$t(t,[],s)},blockItself:Ft,template:$t,loc:zt,pos:function(t,e){return Ut.pos({line:t,column:e})},path:Bt,fullPath:function(t,e=[],s){return Ut.path({head:t,tail:e,loc:zt(s||null)})},head:function(t,e){return Ut.head({original:t,loc:zt(e||null)})},at:function(t,e){return Ut.atName({name:t,loc:zt(e||null)})},var:Tt,this:function(t){return Ut.this({loc:zt(t||null)})},string:It("StringLiteral"),boolean:It("BooleanLiteral"),number:It("NumberLiteral"),undefined:()=>Lt("UndefinedLiteral",void 0),null:()=>Lt("NullLiteral",null)};function It(t){return function(e,s){return Lt(t,e,s)}}const _t={close:!1,open:!1},Ut=new class{pos({line:t,column:e}){return{line:t,column:e}}blockItself({body:t,params:e,chained:s=!1,loc:r}){return{type:"Block",body:t,params:e,get blockParams(){return this.params.map((t=>t.name))},set blockParams(t){this.params=t.map((t=>Ut.var({name:t,loc:K.synthetic(t)})))},chained:s,loc:r}}template({body:t,blockParams:e,loc:s}){return{type:"Template",body:t,blockParams:e,loc:s}}mustache({path:t,params:e,hash:s,trusting:r,loc:n,strip:a=_t}){return function({path:t,params:e,hash:s,trusting:r,strip:n,loc:a}){const i={type:"MustacheStatement",path:t,params:e,hash:s,trusting:r,strip:n,loc:a};return Object.defineProperty(i,"escaped",{enumerable:!1,get(){return!this.trusting},set(t){this.trusting=!t}}),i}({path:t,params:e,hash:s,trusting:r,strip:a,loc:n})}block({path:t,params:e,hash:s,defaultBlock:r,elseBlock:n=null,loc:a,openStrip:i=_t,inverseStrip:o=_t,closeStrip:l=_t}){return{type:"BlockStatement",path:t,params:e,hash:s,program:r,inverse:n,loc:a,openStrip:i,inverseStrip:o,closeStrip:l}}comment({value:t,loc:e}){return{type:"CommentStatement",value:t,loc:e}}mustacheComment({value:t,loc:e}){return{type:"MustacheCommentStatement",value:t,loc:e}}concat({parts:t,loc:e}){return{type:"ConcatStatement",parts:t,loc:e}}element({path:t,selfClosing:e,attributes:s,modifiers:r,params:n,comments:a,children:i,openTag:o,closeTag:l,loc:c}){let h=e;return{type:"ElementNode",path:t,attributes:s,modifiers:r,params:n,comments:a,children:i,openTag:o,closeTag:l,loc:c,get tag(){return this.path.original},set tag(t){this.path.original=t},get blockParams(){return this.params.map((t=>t.name))},set blockParams(t){this.params=t.map((t=>Ut.var({name:t,loc:K.synthetic(t)})))},get selfClosing(){return h},set selfClosing(t){h=t,this.closeTag=t?null:K.synthetic(`</${this.tag}>`)}}}elementModifier({path:t,params:e,hash:s,loc:r}){return{type:"ElementModifierStatement",path:t,params:e,hash:s,loc:r}}attr({name:t,value:e,loc:s}){return{type:"AttrNode",name:t,value:e,loc:s}}text({chars:t,loc:e}){return{type:"TextNode",chars:t,loc:e}}sexpr({path:t,params:e,hash:s,loc:r}){return{type:"SubExpression",path:t,params:e,hash:s,loc:r}}path({head:t,tail:e,loc:s}){return function({head:t,tail:e,loc:s}){const r={type:"PathExpression",head:t,tail:e,get original(){return[this.head.original,...this.tail].join(".")},set original(t){let[e,...s]=E(t.split("."));this.head=Mt.head(e,this.head.loc),this.tail=s},loc:s};return Object.defineProperty(r,"parts",{enumerable:!1,get(){let t=E(this.original.split("."));return"this"===t[0]?t.shift():t[0].startsWith("@")&&(t[0]=t[0].slice(1)),Object.freeze(t)},set(t){let e=[...t];"this"===e[0]||e[0]?.startsWith("@")||("ThisHead"===this.head.type?e.unshift("this"):"AtHead"===this.head.type&&(e[0]=`@${e[0]}`)),this.original=e.join(".")}}),Object.defineProperty(r,"this",{enumerable:!1,get(){return"ThisHead"===this.head.type}}),Object.defineProperty(r,"data",{enumerable:!1,get(){return"AtHead"===this.head.type}}),r}({head:t,tail:e,loc:s})}head({original:t,loc:e}){return"this"===t?this.this({loc:e}):"@"===t[0]?this.atName({name:t,loc:e}):this.var({name:t,loc:e})}this({loc:t}){return{type:"ThisHead",get original(){return"this"},loc:t}}atName({name:t,loc:e}){let s="";const r={type:"AtHead",get name(){return s},set name(t){t[0],t.indexOf("."),s=t},get original(){return this.name},set original(t){this.name=t},loc:e};return r.name=t,r}var({name:t,loc:e}){let s="";const r={type:"VarHead",get name(){return s},set name(t){t[0],t.indexOf("."),s=t},get original(){return this.name},set original(t){this.name=t},loc:e};return r.name=t,r}hash({pairs:t,loc:e}){return{type:"Hash",pairs:t,loc:e}}pair({key:t,value:e,loc:s}){return{type:"HashPair",key:t,value:e,loc:s}}literal({type:t,value:e,loc:s}){return function({type:t,value:e,loc:s}){const r={type:t,value:e,loc:s};return Object.defineProperty(r,"original",{enumerable:!1,get(){return this.value},set(t){this.value=t}}),r}({type:t,value:e,loc:s})}};class Vt{elementStack=[];lines;source;currentAttribute=null;currentNode=null;tokenizer;constructor(t,e=new i(o),s="precompile"){this.source=t,this.lines=t.source.split(/\r\n?|\n/u),this.tokenizer=new a(this,e,s)}offset(){let{line:t,column:e}=this.tokenizer;return this.source.offsetFor(t,e)}pos({line:t,column:e}){return this.source.offsetFor(t,e)}finish(t){return e({},t,{loc:t.start.until(this.offset())})}get currentAttr(){return this.currentAttribute}get currentTag(){let t=this.currentNode;return t&&("StartTag"===t.type||t.type),t}get currentStartTag(){let t=this.currentNode;return t&&t.type,t}get currentEndTag(){let t=this.currentNode;return t&&t.type,t}get currentComment(){let t=this.currentNode;return t&&t.type,t}get currentData(){let t=this.currentNode;return t&&t.type,t}acceptNode(t){return this[t.type](t)}currentElement(){return N(E(this.elementStack))}sourceForNode(t,e){let s,r,n,a=t.loc.start.line-1,i=a-1,o=t.loc.start.column,l=[];for(e?(r=e.loc.end.line-1,n=e.loc.end.column):(r=t.loc.end.line-1,n=t.loc.end.column);i<r;)i++,s=this.lines[i],i===a?a===r?l.push(s.slice(o,n)):l.push(s.slice(o)):i===r?l.push(s.slice(0,n)):l.push(s);return l.join("\n")}}const Dt="beforeAttributeName";class jt extends Vt{pendingError=null;parse(t,e){let s=Ut.template({body:[],blockParams:e,loc:this.source.spanFor(t.loc)}),r=this.parseProgram(s,t);return this.pendingError?.eof(r.loc.getEnd()),r}Program(t,e){let s=Ut.blockItself({body:[],params:e,chained:t.chained,loc:this.source.spanFor(t.loc)});return this.parseProgram(s,t)}parseProgram(t,e){if(0===e.body.length)return t;let s;try{this.elementStack.push(t);for(let t of e.body)this.acceptNode(t)}finally{s=this.elementStack.pop()}if(t!==s){if("ElementNode"===s?.type)throw ot(`Unclosed element \`${s.tag}\``,s.loc);t.type}return t}BlockStatement(t){if("comment"===this.tokenizer.state)return void this.appendToCommentData(this.sourceForNode(t));if("data"!==this.tokenizer.state&&"beforeData"!==this.tokenizer.state)throw ot("A block may only be used inside an HTML element or another block.",this.source.spanFor(t.loc));const{path:e,params:s,hash:r}=Kt(this,t),n=this.source.spanFor(t.loc);let a=[];if(t.program.blockParams?.length){let e=r.loc.collapse("end");e=t.program.loc?e.withEnd(this.source.spanFor(t.program.loc).getStart()):t.program.body[0]?e.withEnd(this.source.spanFor(t.program.body[0].loc).getStart()):e.withEnd(n.getEnd());const s=e.asString();let i=s.indexOf("|")+1;const o=s.indexOf("|",i);for(const r of t.program.blockParams){let t,n;t=i>=o?-1:s.indexOf(r,i),-1===t||t+r.length>o?(i=o,n=this.source.spanFor(B)):(i=t,n=e.sliceStartChars({skipStart:i,chars:r.length}),i+=r.length),a.push(Ut.var({name:r,loc:n}))}}t.program.loc||(t.program.loc=B),t.inverse&&!t.inverse.loc&&(t.inverse.loc=B);const i=this.Program(t.program,a),o=t.inverse?this.Program(t.inverse,[]):null,l=Ut.block({path:e,params:s,hash:r,defaultBlock:i,elseBlock:o,loc:this.source.spanFor(t.loc),openStrip:t.openStrip,inverseStrip:t.inverseStrip,closeStrip:t.closeStrip});Et(this.currentElement(),l)}MustacheStatement(t){this.pendingError?.mustache(this.source.spanFor(t.loc));const{tokenizer:e}=this;if("comment"===e.state)return void this.appendToCommentData(this.sourceForNode(t));let s;const{escaped:r,loc:n,strip:a}=t;if("original"in t.path&&"...attributes"===t.path.original)throw ot("Illegal use of ...attributes",this.source.spanFor(t.loc));if(Nt(t.path))s=Ut.mustache({path:this.acceptNode(t.path),params:[],hash:Ut.hash({pairs:[],loc:this.source.spanFor(t.path.loc).collapse("end")}),trusting:!r,loc:this.source.spanFor(n),strip:a});else{const{path:e,params:i,hash:o}=Kt(this,t);s=Ut.mustache({path:e,params:i,hash:o,trusting:!r,loc:this.source.spanFor(n),strip:a})}switch(e.state){case"tagOpen":case"tagName":throw ot("Cannot use mustaches in an elements tagname",s.loc);case"beforeAttributeName":Jt(this.currentStartTag,s);break;case"attributeName":case"afterAttributeName":this.beginAttributeValue(!1),this.finishAttributeValue(),Jt(this.currentStartTag,s),e.transitionTo(Dt);break;case"afterAttributeValueQuoted":Jt(this.currentStartTag,s),e.transitionTo(Dt);break;case"beforeAttributeValue":this.beginAttributeValue(!1),this.appendDynamicAttributeValuePart(s),e.transitionTo("attributeValueUnquoted");break;case"attributeValueDoubleQuoted":case"attributeValueSingleQuoted":case"attributeValueUnquoted":this.appendDynamicAttributeValuePart(s);break;default:Et(this.currentElement(),s)}return s}appendDynamicAttributeValuePart(t){this.finalizeTextPart();const e=this.currentAttr;e.isDynamic=!0,e.parts.push(t)}finalizeTextPart(){const t=this.currentAttr.currentPart;null!==t&&(this.currentAttr.parts.push(t),this.startTextPart())}startTextPart(){this.currentAttr.currentPart=null}ContentStatement(t){!function(t,e){let s=e.loc.start.line,r=e.loc.start.column;const n=function(t,e){if(""===e)return{lines:t.split("\n").length-1,columns:0};const[s]=t.split(e),r=s.split(/\n/u),n=r.length-1;return{lines:n,columns:r[n].length}}(e.original,e.value);s+=n.lines,n.lines?r=n.columns:r+=n.columns,t.line=s,t.column=r}(this.tokenizer,t),this.tokenizer.tokenizePart(t.value),this.tokenizer.flushData()}CommentStatement(t){const{tokenizer:e}=this;if("comment"===e.state)return this.appendToCommentData(this.sourceForNode(t)),null;const{value:s,loc:r}=t,n=Ut.mustacheComment({value:s,loc:this.source.spanFor(r)});switch(e.state){case"beforeAttributeName":case"afterAttributeName":this.currentStartTag.comments.push(n);break;case"beforeData":case"data":Et(this.currentElement(),n);break;default:throw ot(`Using a Handlebars comment when in the \`${e.state}\` state is not supported`,this.source.spanFor(t.loc))}return n}PartialStatement(t){throw ot("Handlebars partials are not supported",this.source.spanFor(t.loc))}PartialBlockStatement(t){throw ot("Handlebars partial blocks are not supported",this.source.spanFor(t.loc))}Decorator(t){throw ot("Handlebars decorators are not supported",this.source.spanFor(t.loc))}DecoratorBlock(t){throw ot("Handlebars decorator blocks are not supported",this.source.spanFor(t.loc))}SubExpression(t){const{path:e,params:s,hash:r}=Kt(this,t);return Ut.sexpr({path:e,params:s,hash:r,loc:this.source.spanFor(t.loc)})}PathExpression(t){const{original:e}=t;let s;if(-1!==e.indexOf("/")){if("./"===e.slice(0,2))throw ot('Using "./" is not supported in Glimmer and unnecessary',this.source.spanFor(t.loc));if("../"===e.slice(0,3))throw ot('Changing context using "../" is not supported in Glimmer',this.source.spanFor(t.loc));if(-1!==e.indexOf("."))throw ot("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths",this.source.spanFor(t.loc));s=[t.parts.join("/")]}else{if("."===e)throw ot("'.' is not a supported path in Glimmer; check for a path with a trailing '.'",this.source.spanFor(t.loc));s=t.parts}let r,n=!1;if(/^this(?:\..+)?$/u.test(e)&&(n=!0),n)r=Ut.this({loc:this.source.spanFor({start:t.loc.start,end:{line:t.loc.start.line,column:t.loc.start.column+4}})});else if(t.data){const e=s.shift();if(void 0===e)throw ot("Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.",this.source.spanFor(t.loc));r=Ut.atName({name:`@${e}`,loc:this.source.spanFor({start:t.loc.start,end:{line:t.loc.start.line,column:t.loc.start.column+e.length+1}})})}else{const e=s.shift();if(void 0===e)throw ot("Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.",this.source.spanFor(t.loc));r=Ut.var({name:e,loc:this.source.spanFor({start:t.loc.start,end:{line:t.loc.start.line,column:t.loc.start.column+e.length}})})}return Ut.path({head:r,tail:s,loc:this.source.spanFor(t.loc)})}Hash(t){const e=t.pairs.map((t=>Ut.pair({key:t.key,value:this.acceptNode(t.value),loc:this.source.spanFor(t.loc)})));return Ut.hash({pairs:e,loc:this.source.spanFor(t.loc)})}StringLiteral(t){return Ut.literal({type:"StringLiteral",value:t.value,loc:this.source.spanFor(t.loc)})}BooleanLiteral(t){return Ut.literal({type:"BooleanLiteral",value:t.value,loc:this.source.spanFor(t.loc)})}NumberLiteral(t){return Ut.literal({type:"NumberLiteral",value:t.value,loc:this.source.spanFor(t.loc)})}UndefinedLiteral(t){return Ut.literal({type:"UndefinedLiteral",value:void 0,loc:this.source.spanFor(t.loc)})}NullLiteral(t){return Ut.literal({type:"NullLiteral",value:null,loc:this.source.spanFor(t.loc)})}}function Kt(t,e){let s;switch(e.path.type){case"PathExpression":s=t.PathExpression(e.path);break;case"SubExpression":s=t.SubExpression(e.path);break;case"StringLiteral":case"UndefinedLiteral":case"NullLiteral":case"NumberLiteral":case"BooleanLiteral":{let s;throw s="BooleanLiteral"===e.path.type?e.path.original.toString():"StringLiteral"===e.path.type?`"${e.path.original}"`:"NullLiteral"===e.path.type?"null":"NumberLiteral"===e.path.type?e.path.value.toString():"undefined",ot(`${e.path.type} "${"StringLiteral"===e.path.type?e.path.original:s}" cannot be called as a sub-expression, replace (${s}) with ${s}`,t.source.spanFor(e.path.loc))}}const r=e.params?e.params.map((e=>t.acceptNode(e))):[],n=P(r)?N(r).loc:s.loc;return{path:s,params:r,hash:e.hash?t.Hash(e.hash):Ut.hash({pairs:[],loc:t.source.spanFor(n).collapse("end")})}}function Jt(t,e){const{path:s,params:r,hash:n,loc:a}=e;if(Nt(s)){const r=`{{${function(t){return"UndefinedLiteral"===t.type?"undefined":JSON.stringify(t.value)}(s)}}}`;throw ot(`In <${t.name} ... ${r} ..., ${r} is not a valid modifier`,e.loc)}const i=Ut.elementModifier({path:s,params:r,hash:n,loc:a});t.modifiers.push(i)}function Rt(t){return/[\t\n\f ]/u.test(t)}class Gt extends jt{tagOpenLine=0;tagOpenColumn=0;reset(){this.currentNode=null}beginComment(){this.currentNode={type:"CommentStatement",value:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}appendToCommentData(t){this.currentComment.value+=t}finishComment(){Et(this.currentElement(),Ut.comment(this.finish(this.currentComment)))}beginData(){this.currentNode={type:"TextNode",chars:"",start:this.offset()}}appendToData(t){this.currentData.chars+=t}finishData(){Et(this.currentElement(),Ut.text(this.finish(this.currentData)))}tagOpen(){this.tagOpenLine=this.tokenizer.line,this.tagOpenColumn=this.tokenizer.column}beginStartTag(){this.currentNode={type:"StartTag",name:"",nameStart:null,nameEnd:null,attributes:[],modifiers:[],comments:[],params:[],selfClosing:!1,start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}beginEndTag(){this.currentNode={type:"EndTag",name:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}finishTag(){let t=this.finish(this.currentTag);if("StartTag"===t.type){if(this.finishStartTag(),":"===t.name)throw ot("Invalid named block named detected, you may have created a named block without a name, or you may have began your name with a number. Named blocks must have names that are at least one character long, and begin with a lower case letter",this.source.spanFor({start:this.currentTag.start.toJSON(),end:this.offset().toJSON()}));(g.has(t.name)||t.selfClosing)&&this.finishEndTag(!0)}else"EndTag"===t.type&&this.finishEndTag(!1)}finishStartTag(){let{name:t,nameStart:e,nameEnd:s}=this.currentStartTag,r=e.until(s),[n,...a]=E(t.split(".")),i=Ut.path({head:Ut.head({original:n,loc:r.sliceStartChars({chars:n.length})}),tail:a,loc:r}),{attributes:o,modifiers:l,comments:c,params:h,selfClosing:u,loc:p}=this.finish(this.currentStartTag),d=Ut.element({path:i,selfClosing:u,attributes:o,modifiers:l,comments:c,params:h,children:[],openTag:p,closeTag:u?null:K.broken(),loc:p});this.elementStack.push(d)}finishEndTag(t){let{start:e}=this.currentTag,s=this.finish(this.currentTag),r=this.elementStack.pop();this.validateEndTag(s,r,t);let n=this.currentElement();t?r.closeTag=null:r.selfClosing?r.closeTag:r.closeTag=e.until(this.offset()),r.loc=r.loc.withEnd(this.offset()),Et(n,Ut.element(r))}markTagAsSelfClosing(){let t=this.currentTag;if("StartTag"!==t.type)throw ot("Invalid end tag: closing tag must not be self-closing",this.source.spanFor({start:t.start.toJSON(),end:this.offset().toJSON()}));t.selfClosing=!0}appendToTagName(t){let e=this.currentTag;if(e.name+=t,"StartTag"===e.type){let t=this.offset();null===e.nameStart&&(e.nameEnd,e.nameStart=t.move(-1)),e.nameEnd=t}}beginAttribute(){let t=this.offset();this.currentAttribute={name:"",parts:[],currentPart:null,isQuoted:!1,isDynamic:!1,start:t,valueSpan:t.collapsed()}}appendToAttributeName(t){this.currentAttr.name+=t,"as"===this.currentAttr.name&&this.parsePossibleBlockParams()}beginAttributeValue(t){this.currentAttr.isQuoted=t,this.startTextPart(),this.currentAttr.valueSpan=this.offset().collapsed()}appendToAttributeValue(t){let e=this.currentAttr.parts,s=e[e.length-1],r=this.currentAttr.currentPart;if(r)r.chars+=t,r.loc=r.loc.withEnd(this.offset());else{let e=this.offset();e="\n"===t?s?s.loc.getEnd():this.currentAttr.valueSpan.getStart():e.move(-1),this.currentAttr.currentPart=Ut.text({chars:t,loc:e.collapsed()})}}finishAttributeValue(){this.finalizeTextPart();let t=this.currentTag,e=this.offset();if("EndTag"===t.type)throw ot("Invalid end tag: closing tag must not have attributes",this.source.spanFor({start:t.start.toJSON(),end:e.toJSON()}));let{name:s,parts:r,start:n,isQuoted:a,isDynamic:i,valueSpan:o}=this.currentAttr;if(s.startsWith("|")&&0===r.length&&!a&&!i)throw ot("Invalid block parameters syntax: block parameters must be preceded by the `as` keyword",n.until(n.move(s.length)));let l=this.assembleAttributeValue(r,a,i,n.until(e));l.loc=o.withEnd(e);let c=Ut.attr({name:s,value:l,loc:n.until(e)});this.currentStartTag.attributes.push(c)}parsePossibleBlockParams(){const t=/[!"#%&'()*+./;<=>@[\\\]^`{|}~]/u;this.tokenizer.state;const e=this.currentStartTag,s=this.currentAttr;let r={state:"PossibleAs"};const n={PossibleAs:t=>{if(r.state,Rt(t))r={state:"BeforeStartPipe"},this.tokenizer.transitionTo("afterAttributeName"),this.tokenizer.consume();else{if("|"===t)throw ot('Invalid block parameters syntax: expecting at least one space character between "as" and "|"',s.start.until(this.offset().move(1)));r={state:"Done"}}},BeforeStartPipe:t=>{r.state,Rt(t)?this.tokenizer.consume():"|"===t?(r={state:"BeforeBlockParamName"},this.tokenizer.transitionTo("beforeAttributeName"),this.tokenizer.consume()):r={state:"Done"}},BeforeBlockParamName:t=>{if(r.state,Rt(t))this.tokenizer.consume();else if(""===t)r={state:"Done"},this.pendingError={mustache(t){throw ot("Invalid block parameters syntax: mustaches cannot be used inside parameters list",t)},eof(t){throw ot('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(t))}};else if("|"===t){if(0===e.params.length)throw ot("Invalid block parameters syntax: empty parameters list, expecting at least one identifier",s.start.until(this.offset().move(1)));r={state:"AfterEndPipe"},this.tokenizer.consume()}else{if(">"===t||"/"===t)throw ot('Invalid block parameters syntax: incomplete parameters list, expecting "|" but the tag was closed prematurely',s.start.until(this.offset().move(1)));r={state:"BlockParamName",name:t,start:this.offset()},this.tokenizer.consume()}},BlockParamName:n=>{if(r.state,""===n)r={state:"Done"},this.pendingError={mustache(t){throw ot("Invalid block parameters syntax: mustaches cannot be used inside parameters list",t)},eof(t){throw ot('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(t))}};else if("|"===n||Rt(n)){let s=r.start.until(this.offset());if("this"===r.name||t.test(r.name))throw ot(`Invalid block parameters syntax: invalid identifier name \`${r.name}\``,s);e.params.push(Ut.var({name:r.name,loc:s})),r="|"===n?{state:"AfterEndPipe"}:{state:"BeforeBlockParamName"},this.tokenizer.consume()}else{if(">"===n||"/"===n)throw ot('Invalid block parameters syntax: expecting "|" but the tag was closed prematurely',s.start.until(this.offset().move(1)));r.name+=n,this.tokenizer.consume()}},AfterEndPipe:t=>{r.state,Rt(t)?this.tokenizer.consume():""===t?(r={state:"Done"},this.pendingError={mustache(t){throw ot("Invalid block parameters syntax: modifiers cannot follow parameters list",t)},eof(t){throw ot('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(t))}}):">"===t||"/"===t?r={state:"Done"}:(r={state:"Error",message:'Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',start:this.offset()},this.tokenizer.consume())},Error:t=>{if(r.state,""===t||"/"===t||">"===t||Rt(t))throw ot(r.message,r.start.until(this.offset()));this.tokenizer.consume()},Done:()=>{}};let a;do{a=this.tokenizer.peek(),n[r.state](a)}while("Done"!==r.state&&""!==a);r.state}reportSyntaxError(t){throw ot(t,this.offset().collapsed())}assembleConcatenatedValue(t){for(const e of t)if("MustacheStatement"!==e.type&&"TextNode"!==e.type)throw ot(`Unsupported node in quoted attribute value: ${e.type}`,e.loc);let e=C(t),s=N(t);return Ut.concat({parts:t,loc:this.source.spanFor(e.loc).extend(this.source.spanFor(s.loc))})}validateEndTag(t,e,s){if(g.has(t.name)&&!s)throw ot(`<${t.name}> elements do not need end tags. You should remove it`,t.loc);if(void 0===e.tag)throw ot(`Closing tag </${t.name}> without an open tag`,t.loc);if(e.tag!==t.name)throw ot(`Closing tag </${t.name}> did not match last open tag <${e.tag}> (on line ${e.loc.startPosition.line})`,t.loc)}assembleAttributeValue(t,e,s,r){if(s){if(e)return this.assembleConcatenatedValue(t);{const[e,s]=t;if(void 0===s||"TextNode"===s.type&&"/"===s.chars)return e;throw ot("An unquoted attribute value must be a string or a mustache, preceded by whitespace or a '=' character, and followed by whitespace, a '>' character, or '/>'",r)}}return P(t)?t[0]:Ut.text({chars:"",loc:r})}}const Yt={parse:qt,builders:Mt,print:v,traverse:St,Walker:xt};class Wt extends i{constructor(){super({})}parse(){}}function qt(t,s={}){let a,i,o,l=s.mode||"precompile";"string"==typeof t?(a=new et(t,s.meta?.moduleName),i="codemod"===l?r(t,s.parseOptions):n(t,s.parseOptions)):t instanceof et?(a=t,i="codemod"===l?r(t.source,s.parseOptions):n(t.source,s.parseOptions)):(a=new et("",s.meta?.moduleName),i=t),"codemod"===l&&(o=new Wt);let c=K.forCharPositions(a,0,a.source.length);i.loc={source:"(program)",start:c.startPosition,end:c.endPosition};let h=new Gt(a,o,l).parse(i,s.locals??[]);if(s?.plugins?.ast)for(const t of s.plugins.ast)St(h,t(e({},s,{syntax:Yt},{plugins:void 0})).visitor);return h}function Qt(t,e,s,r){const n=function(t,e,s){if("PathExpression"===t.type){if("AtHead"===t.head.type||"ThisHead"===t.head.type)return;const s=t.head.name;if(-1===e.indexOf(s))return s}else if("ElementNode"===t.type){const{tag:r}=t,n=r.charAt(0);if(":"===n||"@"===n)return;if(!s.includeHtmlElements&&-1===r.indexOf(".")&&r.toLowerCase()===r)return;if("this."===r.substr(0,5))return;if(r.includes(".")){let[t]=r.split(".");if(e.includes(t))return}if(e.includes(r))return;return r}}(e,s,r);(Array.isArray(n)?n:[n]).forEach((e=>{if(void 0!==e&&"@"!==e[0]){const r=e.split(".")[0];s.includes(r)||t.add(e.split(".")[0])}}))}function Xt(t,e={includeHtmlElements:!1,includeKeywords:!1}){const s=qt(t),r=new Set,n=[];St(s,{Block:{enter({blockParams:t}){t.forEach((t=>{n.push(t)}))},exit({blockParams:t}){t.forEach((()=>{n.pop()}))}},ElementNode:{enter(t){t.blockParams.forEach((t=>{n.push(t)})),Qt(r,t,n,e)},exit({blockParams:t}){t.forEach((()=>{n.pop()}))}},PathExpression(t){Qt(r,t,n,e)}});let a=[];return r.forEach((t=>a.push(t))),e?.includeKeywords||(a=a.filter((t=>!S(t)))),a}function Zt(t){if(void 0!==t){const s=t;return{fields:()=>class{type;constructor(t){this.type=s,e(this,t)}}}}return{fields:()=>class{constructor(t){e(this,t)}}}}class te extends(Zt().fields()){static empty(t){return new te({loc:t,positional:ee.empty(t),named:se.empty(t)})}static named(t){return new te({loc:t.loc,positional:ee.empty(t.loc.collapse("end")),named:t})}nth(t){return this.positional.nth(t)}get(t){return this.named.get(t)}isEmpty(){return this.positional.isEmpty()&&this.named.isEmpty()}}class ee extends(Zt().fields()){static empty(t){return new ee({loc:t,exprs:[]})}get size(){return this.exprs.length}nth(t){return this.exprs[t]||null}isEmpty(){return 0===this.exprs.length}}class se extends(Zt().fields()){static empty(t){return new se({loc:t,entries:[]})}get size(){return this.entries.length}get(t){let e=this.entries.filter((e=>e.name.chars===t))[0];return e?e.value:null}isEmpty(){return 0===this.entries.length}}class re{loc;name;value;constructor(t){this.loc=t.name.loc.extend(t.value.loc),this.name=t.name,this.value=t.value}}class ne extends(Zt("HtmlAttr").fields()){}class ae extends(Zt("SplatAttr").fields()){}class ie extends(Zt().fields()){toNamedArgument(){return new re({name:this.name,value:this.value})}}class oe extends(Zt("ElementModifier").fields()){}class le extends(Zt("GlimmerComment").fields()){}class ce extends(Zt("HtmlText").fields()){}class he extends(Zt("HtmlComment").fields()){}class ue extends(Zt("AppendContent").fields()){get callee(){return"Call"===this.value.type?this.value.callee:this.value}get args(){return"Call"===this.value.type?this.value.args:te.empty(this.value.loc.collapse("end"))}}class pe extends(Zt("InvokeBlock").fields()){}class de extends(Zt("InvokeComponent").fields()){get args(){let t=this.componentArgs.map((t=>t.toNamedArgument()));return te.named(new se({loc:st.range(t,this.callee.loc.collapse("end")),entries:t}))}}class me extends(Zt("SimpleElement").fields()){get args(){let t=this.componentArgs.map((t=>t.toNamedArgument()));return te.named(new se({loc:st.range(t,this.tag.loc.collapse("end")),entries:t}))}}class fe extends(Zt("Literal").fields()){toSlice(){return new j({loc:this.loc,chars:this.value})}}class ge extends(Zt("Path").fields()){}class be extends(Zt("Keyword").fields()){}class ke extends(Zt("Call").fields()){}class we extends(Zt("Interpolate").fields()){}class ye extends(Zt().fields()){}class ve extends(Zt().fields()){}class Se extends(Zt().fields()){get(t){return this.blocks.filter((e=>e.name.chars===t))[0]||null}}class xe extends(Zt().fields()){get args(){let t=this.componentArgs.map((t=>t.toNamedArgument()));return te.named(new se({loc:st.range(t,this.name.loc.collapse("end")),entries:t}))}}class Pe extends(Zt("This").fields()){}class Ee extends(Zt("Arg").fields()){}class Ne extends(Zt("Local").fields()){}class Ce extends(Zt("Free").fields()){}const Ae="Helper",Te="Modifier",Be="Component",Le={resolution:()=>l.GetStrictKeyword,serialize:()=>"Strict",isAngleBracket:!1},Oe={...Le,isAngleBracket:!0};class He{static namespaced(t,e=!1){return new He([t],e)}static append(){return new He([Be,Ae])}static trustingAppend(){return this.namespaced(Ae)}constructor(t,e=!1){this.namespaces=t,this.isAngleBracket=e}resolution(){if(1!==this.namespaces.length)return l.GetFreeAsComponentOrHelperHead;switch(this.namespaces[0]){case Ae:return l.GetFreeAsHelperHead;case Te:return l.GetFreeAsModifierHead;case Be:return l.GetFreeAsComponentHead}}serialize(){return 1===this.namespaces.length?this.namespaces[0]:"ComponentOrHelper"}}const Fe=Ae,$e=Te,ze=Be;var Me=Object.freeze({__proto__:null,AppendContent:ue,ArgReference:Ee,Args:te,Block:ve,COMPONENT_NAMESPACE:ze,CallExpression:ke,ComponentArg:ie,ElementModifier:oe,FreeVarReference:Ce,GlimmerComment:le,HELPER_NAMESPACE:Fe,HTML_RESOLUTION:Oe,HtmlAttr:ne,HtmlComment:he,HtmlText:ce,InterpolateExpression:we,InvokeBlock:pe,InvokeComponent:de,KeywordExpression:be,LiteralExpression:fe,LocalVarReference:Ne,LooseModeResolution:He,MODIFIER_NAMESPACE:$e,NamedArgument:re,NamedArguments:se,NamedBlock:xe,NamedBlocks:Se,PathExpression:ge,PositionalArguments:ee,STRICT_RESOLUTION:Le,SimpleElement:me,SplatAttr:ae,Template:ye,ThisReference:Pe,isLiteral:function(t,e){return"Literal"===t.type&&(void 0===e||("null"===e?null===t.value:typeof t.value===e))},isStrictResolution:function(t){return t===Le},loadResolution:function(t){return"Strict"===t?Le:"ComponentOrHelper"===t?He.append():He.namespaced(t)},node:Zt});class Ie{static top(t,e,s){return new _e(t,e,s)}child(t){let e=t.map((t=>this.allocate(t)));return new Ue(this,t,e)}}class _e extends Ie{constructor(t,e,s){super(),this.templateLocals=t,this.keywords=e,this.options=s}symbols=[];upvars=[];size=1;named=s();blocks=s();usedTemplateLocals=[];root(){return this}hasLexical(t){return this.options.lexicalScope(t)}hasKeyword(t){return this.keywords.includes(t)}getKeyword(t){return this.allocateFree(t,Le)}getUsedTemplateLocals(){return this.usedTemplateLocals}has(t){return this.templateLocals.includes(t)}get(t){let e=this.usedTemplateLocals.indexOf(t);return-1!==e||(e=this.usedTemplateLocals.length,this.usedTemplateLocals.push(t)),[e,!0]}getLocalsMap(){return s()}getDebugInfo(){return[this.getLocalsMap(),this.named]}allocateFree(t,e){e.resolution()===l.GetFreeAsComponentHead&&e.isAngleBracket&&(t=this.options.customizeComponentName(t));let s=this.upvars.indexOf(t);return-1!==s||(s=this.upvars.length,this.upvars.push(t)),s}allocateNamed(t){let e=this.named[t];return e||(e=this.named[t]=this.allocate(t)),e}allocateBlock(t){"inverse"===t&&(t="else");let e=this.blocks[t];return e||(e=this.blocks[t]=this.allocate(`&${t}`)),e}allocate(t){return this.symbols.push(t),this.size++}}class Ue extends Ie{constructor(t,e,s){super(),this.parent=t,this.symbols=e,this.slots=s}root(){return this.parent.root()}get locals(){return this.symbols}hasLexical(t){return this.parent.hasLexical(t)}getKeyword(t){return this.parent.getKeyword(t)}hasKeyword(t){return this.parent.hasKeyword(t)}has(t){return-1!==this.symbols.indexOf(t)||this.parent.has(t)}get(t){let e=this.#r(t);return e?[e,!1]:this.parent.get(t)}#r(t){let e=this.symbols.indexOf(t);return-1===e?null:this.slots[e]}getLocalsMap(){let t=this.parent.getLocalsMap();return this.symbols.forEach((e=>t[e]=this.get(e)[0])),t}getDebugInfo(){const t=this.getLocalsMap(),e=this.root();return[{...t,...e.named},Object.fromEntries(e.upvars.map(((t,e)=>[t,e])))]}allocateFree(t,e){return this.parent.allocateFree(t,e)}allocateNamed(t){return this.parent.allocateNamed(t)}allocateBlock(t){return this.parent.allocateBlock(t)}allocate(t){return this.parent.allocate(t)}}var Ve=Object.freeze({__proto__:null});class De{template(t,e,s){return new ye({table:t,body:e,loc:s})}block(t,e,s){return new ve({scope:t,body:e,loc:s})}namedBlock(t,e,s){return new xe({name:t,block:e,attrs:[],componentArgs:[],modifiers:[],loc:s})}simpleNamedBlock(t,e,s){return new je({selfClosing:!1,attrs:[],componentArgs:[],modifiers:[],comments:[]}).named(t,e,s)}slice(t,e){return new j({loc:e,chars:t})}args(t,e,s){return new te({loc:s,positional:t,named:e})}positional(t,e){return new ee({loc:e,exprs:t})}namedArgument(t,e){return new re({name:t,value:e})}named(t,e){return new se({loc:e,entries:t})}attr({name:t,value:e,trusting:s},r){return new ne({loc:r,name:t,value:e,trusting:s})}splatAttr(t,e){return new ae({symbol:t,loc:e})}arg({name:t,value:e,trusting:s},r){return new ie({name:t,value:e,trusting:s,loc:r})}path(t,e,s){return new ge({loc:s,ref:t,tail:e})}keyword(t,e,s){return new be({loc:s,name:t,symbol:e})}self(t){return new Pe({loc:t})}at(t,e,s){return t[0],new Ee({loc:s,name:new j({loc:s,chars:t}),symbol:e})}freeVar({name:t,context:e,symbol:s,loc:r}){return t[0],new Ce({name:t,resolution:e,symbol:s,loc:r})}localVar(t,e,s,r){return t[0],new Ne({loc:r,name:t,isTemplateLocal:s,symbol:e})}sexp(t,e){return new ke({loc:e,callee:t.callee,args:t.args})}interpolate(t,e){return new we({loc:e,parts:t})}literal(t,e){return new fe({loc:e,value:t})}append({table:t,trusting:e,value:s},r){return new ue({table:t,trusting:e,value:s,loc:r})}modifier({callee:t,args:e},s){return new oe({loc:s,callee:t,args:e})}namedBlocks(t,e){return new Se({loc:e,blocks:t})}blockStatement({program:t,inverse:e=null,...s},r){let n=t.loc,a=[this.namedBlock(j.synthetic("default"),t,t.loc)];return e&&(n=n.extend(e.loc),a.push(this.namedBlock(j.synthetic("else"),e,e.loc))),new pe({loc:r,blocks:this.namedBlocks(a,n),callee:s.callee,args:s.args})}element(t){return new je(t)}}class je{builder;constructor(t){this.base=t,this.builder=new De}simple(t,s,r){return new me(e({tag:t,body:s,componentArgs:[],loc:r},this.base))}named(t,s,r){return new xe(e({name:t,block:s,componentArgs:[],loc:r},this.base))}selfClosingComponent(t,s){return new de(e({loc:s,callee:t,blocks:new Se({blocks:[],loc:s.sliceEndChars({skipEnd:1,chars:1})})},this.base))}componentWithDefaultBlock(t,s,r,n){let a=this.builder.block(r,s,n),i=this.builder.namedBlock(j.synthetic("default"),a,n);return new de(e({loc:n,callee:t,blocks:this.builder.namedBlocks([i],i.loc)},this.base))}componentWithNamedBlocks(t,s,r){return new de(e({loc:r,callee:t,blocks:this.builder.namedBlocks(s,st.range(s))},this.base))}}function Ke(t){return qe(t)?He.namespaced(Fe):null}function Je(t){return qe(t)?He.namespaced($e):null}function Re(t){return qe(t)?He.namespaced(ze):null}function Ge(t){return Qe(t)?He.namespaced(ze,!0):null}function Ye(t){return qe(t)?He.namespaced(Fe):null}function We(t){let e=qe(t),s=t.trusting;return e?s?He.trustingAppend():He.append():null}function qe(t){return Qe(t.path)}function Qe(t){return"PathExpression"===t.type&&"VarHead"===t.head.type&&0===t.tail.length}function Xe(t,e={lexicalScope:()=>!1}){let s=qt(t,e),r={strictMode:!1,...e,locals:s.blockParams,keywords:e.keywords??[]},n=Ie.top(r.locals,r.keywords,{customizeComponentName:e.customizeComponentName??(t=>t),lexicalScope:e.lexicalScope}),a=new Ze(t,r,n),i=new es(a),o=new ns(a.loc(s.loc),s.body.map((t=>i.normalize(t))),a).assertTemplate(n);return[o,n.getUsedTemplateLocals()]}class Ze{builder;constructor(t,e,s){this.source=t,this.options=e,this.table=s,this.builder=new De}get strict(){return this.options.strictMode||!1}loc(t){return this.source.spanFor(t)}resolutionFor(t,e){if(this.strict)return{result:Le};if(this.isFreeVar(t)){let s=e(t);return null===s?{result:"error",path:cs(t),head:hs(t)}:{result:s}}return{result:Le}}isLexicalVar(t){return this.table.hasLexical(t)}isKeyword(t){return this.strict&&!this.table.hasLexical(t)&&this.table.hasKeyword(t)}isFreeVar(t){return"PathExpression"===t.type?"VarHead"===t.head.type&&!this.table.has(t.head.name):"PathExpression"===t.path.type&&this.isFreeVar(t.path)}hasBinding(t){return this.table.has(t)||this.table.hasLexical(t)}child(t){return new Ze(this.source,this.options,this.table.child(t))}customizeComponentName(t){return this.options.customizeComponentName?this.options.customizeComponentName(t):t}}class ts{constructor(t){this.block=t}normalize(t,e){switch(t.type){case"NullLiteral":case"BooleanLiteral":case"NumberLiteral":case"StringLiteral":case"UndefinedLiteral":return this.block.builder.literal(t.value,this.block.loc(t.loc));case"PathExpression":return this.path(t,e);case"SubExpression":{os(t.path)&&ls(t.path,t.loc);let e=this.block.resolutionFor(t,Ke);if("error"===e.result)throw ot(`You attempted to invoke a path (\`${e.path}\`) but ${e.head} was not in scope`,t.loc);return this.block.builder.sexp(this.callParts(t,e.result),this.block.loc(t.loc))}}}path(t,e){let s=this.block.loc(t.loc);if("VarHead"===t.head.type&&0===t.tail.length&&this.block.isKeyword(t.head.name))return this.block.builder.keyword(t.head.name,this.block.table.getKeyword(t.head.name),s);let r=[],n=this.block.loc(t.head.loc);for(let e of t.tail)n=n.sliceStartChars({chars:e.length,skipStart:1}),r.push(new j({loc:n,chars:e}));return this.block.builder.path(this.ref(t.head,e),r,s)}callParts(t,e){let{path:s,params:r,hash:n,loc:a}=t,i=this.normalize(s,e),o=r.map((t=>this.normalize(t,Le))),l=st.range(o,i.loc.collapse("end")),c=this.block.loc(n.loc),h=st.range([l,c]),u=this.block.builder.positional(r.map((t=>this.normalize(t,Le))),l),p=this.block.builder.named(n.pairs.map((t=>this.namedArgument(t))),this.block.loc(n.loc));switch(i.type){case"Literal":throw ot(`Invalid invocation of a literal value (\`${i.value}\`)`,a);case"Interpolate":throw ot("Invalid invocation of a interpolated string",a)}return{callee:i,args:this.block.builder.args(u,p,h)}}namedArgument(t){let e=this.block.loc(t.loc).sliceStartChars({chars:t.key.length});return this.block.builder.namedArgument(new j({chars:t.key,loc:e}),this.normalize(t.value,Le))}ref(t,e){let{block:s}=this,{builder:r,table:n}=s,a=s.loc(t.loc);switch(t.type){case"ThisHead":return r.self(a);case"AtHead":{let e=n.allocateNamed(t.name);return r.at(t.name,e,a)}case"VarHead":if(s.hasBinding(t.name)){let[e,r]=n.get(t.name);return s.builder.localVar(t.name,e,r,a)}{let r=s.strict?Le:e,n=s.table.allocateFree(t.name,r);return s.builder.freeVar({name:t.name,context:r,symbol:n,loc:a})}}}}class es{constructor(t){this.block=t}normalize(t){switch(t.type){case"BlockStatement":return this.BlockStatement(t);case"ElementNode":return new ss(this.block).ElementNode(t);case"MustacheStatement":return this.MustacheStatement(t);case"MustacheCommentStatement":return this.MustacheCommentStatement(t);case"CommentStatement":{let e=this.block.loc(t.loc);return new he({loc:e,text:e.slice({skipStart:4,skipEnd:3}).toSlice(t.value)})}case"TextNode":return new ce({loc:this.block.loc(t.loc),chars:t.chars})}}MustacheCommentStatement(t){let e,s=this.block.loc(t.loc);return e="{{!--"===s.asString().slice(0,5)?s.slice({skipStart:5,skipEnd:4}):s.slice({skipStart:3,skipEnd:2}),new le({loc:s,text:e.toSlice(t.value)})}MustacheStatement(t){let e,{path:s,params:r,hash:n,trusting:a}=t,i=this.block.loc(t.loc);if(os(s))0===r.length&&0===n.pairs.length?e=this.expr.normalize(s):ls(s,i);else{let a=this.block.resolutionFor(t,We);if("error"===a.result)throw ot(`You attempted to render a path (\`{{${a.path}}}\`), but ${a.head} was not in scope`,i);let o=this.expr.callParts({path:s,params:r,hash:n,loc:i},a.result);e=o.args.isEmpty()?o.callee:this.block.builder.sexp(o,i)}return this.block.builder.append({table:this.block.table,trusting:a,value:e},i)}BlockStatement(t){let{program:s,inverse:r}=t,n=this.block.loc(t.loc);os(t.path)&&ls(t.path,n);let a=this.block.resolutionFor(t,Re);if("error"===a.result)throw ot(`You attempted to invoke a path (\`{{#${a.path}}}\`) but ${a.head} was not in scope`,n);let i=this.expr.callParts(t,a.result);return this.block.builder.blockStatement(e({symbols:this.block.table,program:this.Block(s),inverse:r?this.Block(r):null},i),n)}Block({body:t,loc:e,blockParams:s}){let r=this.block.child(s),n=new es(r);return new as(this.block.loc(e),t.map((t=>n.normalize(t))),this.block).assertBlock(r.table)}get expr(){return new ts(this.block)}}class ss{constructor(t){this.ctx=t}ElementNode(t){let{tag:e,selfClosing:s,comments:r}=t,n=this.ctx.loc(t.loc),[a,...i]=E(e.split(".")),o=this.classifyTag(a,i,t.loc),l=t.attributes.filter((t=>"@"!==t.name[0])).map((t=>this.attr(t))),c=t.attributes.filter((t=>"@"===t.name[0])).map((t=>this.arg(t))),h=t.modifiers.map((t=>this.modifier(t))),u=this.ctx.child(t.blockParams),p=new es(u),d=t.children.map((t=>p.normalize(t))),m=this.ctx.builder.element({selfClosing:s,attrs:l,componentArgs:c,modifiers:h,comments:r.map((t=>new es(this.ctx).MustacheCommentStatement(t)))}),f=new is(m,n,d,this.ctx),g=this.ctx.loc(t.loc).sliceStartChars({chars:e.length,skipStart:1});if("ElementHead"===o)return":"===e[0]?f.assertNamedBlock(g.slice({skipStart:1}).toSlice(e.slice(1)),u.table):f.assertElement(g.toSlice(e),t.blockParams.length>0);if(t.selfClosing)return m.selfClosingComponent(o,n);{let s=f.assertComponent(e,u.table,t.blockParams.length>0);return m.componentWithNamedBlocks(o,s,n)}}modifier(t){os(t.path)&&ls(t.path,t.loc);let e=this.ctx.resolutionFor(t,Je);if("error"===e.result)throw ot(`You attempted to invoke a path (\`{{${e.path}}}\`) as a modifier, but ${e.head} was not in scope`,t.loc);let s=this.expr.callParts(t,e.result);return this.ctx.builder.modifier(s,this.ctx.loc(t.loc))}mustacheAttr(t){let{path:e,params:s,hash:r,loc:n}=t;if(os(e)){if(0===s.length&&0===r.pairs.length)return this.expr.normalize(e);ls(e,n)}let a=this.ctx.resolutionFor(t,Ye);if("error"===a.result)throw ot(`You attempted to render a path (\`{{${a.path}}}\`), but ${a.head} was not in scope`,t.loc);let i=this.ctx.builder.sexp(this.expr.callParts(t,a.result),this.ctx.loc(t.loc));return i.args.isEmpty()?i.callee:i}attrPart(t){switch(t.type){case"MustacheStatement":return{expr:this.mustacheAttr(t),trusting:t.trusting};case"TextNode":return{expr:this.ctx.builder.literal(t.chars,this.ctx.loc(t.loc)),trusting:!0}}}attrValue(t){if("ConcatStatement"===t.type){let e=t.parts.map((t=>this.attrPart(t).expr));return{expr:this.ctx.builder.interpolate(e,this.ctx.loc(t.loc)),trusting:!1}}return this.attrPart(t)}attr(t){if(t.name[0],"...attributes"===t.name)return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock("attrs"),this.ctx.loc(t.loc));let e=this.ctx.loc(t.loc),s=e.sliceStartChars({chars:t.name.length}).toSlice(t.name),r=this.attrValue(t.value);return this.ctx.builder.attr({name:s,value:r.expr,trusting:r.trusting},e)}checkArgCall(t){let{value:e}=t;if("MustacheStatement"!==e.type)return;if(0!==e.params.length||0!==e.hash.pairs.length)return;let{path:s}=e;if("PathExpression"!==s.type)return;if(s.tail.length>0)return;let r=this.ctx.resolutionFor(s,(()=>null));if("error"===r.result&&"has-block"!==r.path)throw ot(`You attempted to pass a path as argument (\`${t.name}={{${r.path}}}\`) but ${r.head} was not in scope. Try:\n* \`${t.name}={{this.${r.path}}}\` if this is meant to be a property lookup, or\n* \`${t.name}={{(${r.path})}}\` if this is meant to invoke the resolved helper, or\n* \`${t.name}={{helper "${r.path}"}}\` if this is meant to pass the resolved helper by value`,t.loc)}arg(t){t.name[0],this.checkArgCall(t);let e=this.ctx.loc(t.loc),s=e.sliceStartChars({chars:t.name.length}).toSlice(t.name),r=this.attrValue(t.value);return this.ctx.builder.arg({name:s,value:r.expr,trusting:r.trusting},e)}classifyTag(t,e,s){let r=(n=t)[0]===n[0]?.toUpperCase()&&n[0]!==n[0]?.toLowerCase();var n;let a="@"===t[0]||"this"===t||this.ctx.hasBinding(t);if(this.ctx.strict&&!a){if(r)throw ot(`Attempted to invoke a component that was not in scope in a strict mode template, \`<${t}>\`. If you wanted to create an element with that name, convert it to lowercase - \`<${t.toLowerCase()}>\``,s);return"ElementHead"}let i=a||r,o=s.sliceStartChars({skipStart:1,chars:t.length}),l=e.reduce(((t,e)=>t+1+e.length),0),c=o.getEnd().move(l),h=o.withEnd(c);if(i){let r=Ut.path({head:Ut.head({original:t,loc:o}),tail:e,loc:h}),n=this.ctx.isLexicalVar(t)?{result:Le}:this.ctx.resolutionFor(r,Ge);if("error"===n.result)throw ot(`You attempted to invoke a path (\`<${n.path}>\`) but ${n.head} was not in scope`,s);return new ts(this.ctx).normalize(r,n.result)}if(this.ctx.table.allocateFree(t,Le),e.length>0)throw ot(`You used ${t}.${e.join(".")} as a tag name, but ${t} is not in scope`,s);return"ElementHead"}get expr(){return new ts(this.ctx)}}class rs{namedBlocks;hasSemanticContent;nonBlockChildren;constructor(t,e,s){this.loc=t,this.children=e,this.block=s,this.namedBlocks=e.filter((t=>t instanceof xe)),this.hasSemanticContent=Boolean(e.filter((t=>{if(t instanceof xe)return!1;switch(t.type){case"GlimmerComment":case"HtmlComment":return!1;case"HtmlText":return!/^\s*$/u.test(t.chars);default:return!0}})).length),this.nonBlockChildren=e.filter((t=>!(t instanceof xe)))}}class ns extends rs{assertTemplate(t){if(P(this.namedBlocks))throw ot("Unexpected named block at the top-level of a template",this.loc);return this.block.builder.template(t,this.nonBlockChildren,this.block.loc(this.loc))}}class as extends rs{assertBlock(t){if(P(this.namedBlocks))throw ot("Unexpected named block nested in a normal block",this.loc);return this.block.builder.block(t,this.nonBlockChildren,this.loc)}}class is extends rs{constructor(t,e,s,r){super(e,s,r),this.el=t}assertNamedBlock(t,e){if(this.el.base.selfClosing)throw ot(`<:${t.chars}/> is not a valid named block: named blocks cannot be self-closing`,this.loc);if(P(this.namedBlocks))throw ot(`Unexpected named block inside <:${t.chars}> named block: named blocks cannot contain nested named blocks`,this.loc);if((s=t.chars)[0]!==s[0]?.toLowerCase()||s[0]===s[0]?.toUpperCase())throw ot(`<:${t.chars}> is not a valid named block, and named blocks must begin with a lowercase letter`,this.loc);var s;if(this.el.base.attrs.length>0||this.el.base.componentArgs.length>0||this.el.base.modifiers.length>0)throw ot(`named block <:${t.chars}> cannot have attributes, arguments, or modifiers`,this.loc);let r=st.range(this.nonBlockChildren,this.loc);return this.block.builder.namedBlock(t,this.block.builder.block(e,this.nonBlockChildren,r),this.loc)}assertElement(t,e){if(e)throw ot(`Unexpected block params in <${t.chars}>: simple elements cannot have block params`,this.loc);if(P(this.namedBlocks)){let e=this.namedBlocks.map((t=>t.name));if(1===e.length)throw ot(`Unexpected named block <:foo> inside <${t.chars}> HTML element`,this.loc);{let s=e.map((t=>`<:${t.chars}>`)).join(", ");throw ot(`Unexpected named blocks inside <${t.chars}> HTML element (${s})`,this.loc)}}return this.el.simple(t,this.nonBlockChildren,this.loc)}assertComponent(t,e,s){if(P(this.namedBlocks)&&this.hasSemanticContent)throw ot(`Unexpected content inside <${t}> component invocation: when using named blocks, the tag cannot contain other content`,this.loc);if(P(this.namedBlocks)){if(s)throw ot(`Unexpected block params list on <${t}> component invocation: when passing named blocks, the invocation tag cannot take block params`,this.loc);let e=new Set;for(let t of this.namedBlocks){let s=t.name.chars;if(e.has(s))throw ot(`Component had two named blocks with the same name, \`<:${s}>\`. Only one block with a given name may be passed`,this.loc);if("inverse"===s&&e.has("else")||"else"===s&&e.has("inverse"))throw ot("Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>",this.loc);e.add(s)}return this.namedBlocks}return[this.block.builder.namedBlock(j.synthetic("default"),this.block.builder.block(e,this.nonBlockChildren,this.loc),this.loc)]}}function os(t){switch(t.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return!0;default:return!1}}function ls(t,e){throw ot(`Unexpected literal \`${"StringLiteral"===t.type?JSON.stringify(t.value):String(t.value)}\``,e)}function cs(t){return"PathExpression"!==t.type&&"PathExpression"===t.path.type?cs(t.path):new y({entityEncoding:"raw"}).print(t)}function hs(t){return"PathExpression"===t.type?t.head.original:"PathExpression"===t.path.type?hs(t.path):new y({entityEncoding:"raw"}).print(t)}export{Ve as AST,Ve as ASTv1,Me as ASTv2,Ue as BlockSymbolTable,x as KEYWORDS_TYPES,xt as Path,_e as ProgramSymbolTable,j as SourceSlice,st as SpanList,Ie as SymbolTable,xt as Walker,dt as WalkerPath,Mt as builders,ht as cannotRemoveNode,ut as cannotReplaceNode,ot as generateSyntaxError,Xt as getTemplateLocals,b as getVoidTags,nt as hasSpan,S as isKeyword,w as isVoidTag,rt as loc,at as maybeLoc,Zt as node,Xe as normalize,qt as preprocess,v as print,f as sortByLoc,it as src,St as traverse,lt as visitorKeys};
//# sourceMappingURL=index.js.map
