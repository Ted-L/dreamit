import GlimmerASTMappingTree from './glimmer-ast-mapping-tree.js';
import { CodeMapping } from '@volar/language-core';
export type Range = {
    start: number;
    end: number;
};
export type RangeWithMapping = Range & {
    mapping?: GlimmerASTMappingTree;
};
export type RangeWithMappingAndSource = RangeWithMapping & {
    source: SourceFile;
};
export type CorrelatedSpan = {
    /** Where this span of content originated */
    originalFile: SourceFile;
    /** The offset where this content began in its original source */
    originalStart: number;
    /** The length of this span's content in its original source */
    originalLength: number;
    /** The location in the untransformed source where this span is spliced in */
    insertionPoint: number;
    /** The contents of this span in the transformed output */
    transformedSource: string;
    /** The offset in the transformed output of this span */
    transformedStart: number;
    /** The length of this span in the transformed output */
    transformedLength: number;
    /** (Glimmer/Handlebars spans only:) A mapping of offsets within this span between its original and transformed versions */
    glimmerAstMapping?: GlimmerASTMappingTree;
};
export type DirectiveKind = 'ignore' | 'expect-error';
export type Directive = {
    kind: DirectiveKind;
    source: SourceFile;
    location: Range;
    areaOfEffect: Range;
};
export type TransformError = {
    isContentTagError?: boolean;
    message: string;
    location: Range;
    source: SourceFile;
};
export type SourceFile = {
    filename: string;
    contents: string;
};
/**
 * This class represents the result of transforming a TypeScript
 * module with one or more embedded HBS templates. It contains
 * both the original and transformed source text of the module, as
 * well any errors encountered during transformation.
 *
 * It is used heavily for bidirectional source mapping between the original TS/HBS code
 * and the singular transformed TS output (aka the Intermediate Representation).
 * It can be queried with an offset or range in either the
 * original or transformed source to determine the corresponding
 * offset or range in the other.
 */
export default class TransformedModule {
    readonly transformedContents: string;
    readonly errors: ReadonlyArray<TransformError>;
    readonly directives: ReadonlyArray<Directive>;
    private readonly correlatedSpans;
    constructor(transformedContents: string, errors: ReadonlyArray<TransformError>, directives: ReadonlyArray<Directive>, correlatedSpans: Array<CorrelatedSpan>);
    toDebugString(): string;
    getOriginalOffset(transformedOffset: number): {
        source?: SourceFile;
        offset: number;
    };
    getTransformedOffset(originalFileName: string, originalOffset: number): number;
    getOriginalRange(transformedStart: number, transformedEnd: number): RangeWithMappingAndSource;
    getTransformedRange(originalFileName: string, originalStart: number, originalEnd: number): RangeWithMapping;
    findTemplateAtOriginalOffset(originalFileName: string, originalOffset: number): {
        originalContentStart: number;
        originalContentEnd: number;
        originalContent: string;
    } | null;
    private determineOriginalOffsetAndSpan;
    private determineTransformedOffsetAndSpan;
    /**
     * Converts the mappings in this transformed module to the format expected by Volar.
     *
     * The main difference between the two formats is that while the classic Glint transformation
     * mappings support mapping a differently sized source region to a differently sized target region
     * (e.g. `{{expectsAtLeastOneArg}}` in an .hbs file to `__glintDSL__.emitContent(__glintDSL__.resolveOrReturn(expectsAtLeastOneArg)());`
     * in a generated TS file, in Volar you can only map regions of the same size.
     *
     * In the case that you need to map regions of different sizes in Volar, you need to also using
     * zero-length mappings to delineate regions/boundaries that should map to each other, otherwise there will
     * be cases where TS diagnostics will fail to transform/map back to the original source. Example:
     *
     * - `{{[[ZEROLEN-A]][[expectsAtLeastOneArg]][[ZEROLEN-B]]}}`
     * - to
     * - `[[ZEROLEN-A]]__glintDSL__.emitContent(__glintDSL__.resolveOrReturn([[expectsAtLeastOneArg]])());[[ZEROLEN-B]]`
     */
    toVolarMappings(filenameFilter?: string): CodeMapping[];
}
//# sourceMappingURL=transformed-module.d.ts.map