{"version":3,"file":"node-resolve.js","sourceRoot":"","sources":["node-resolve.ts"],"names":[],"mappings":";;AAGA,0BAyDC;AA5DD,+BAAmE;AACnE,kEAA+D;AAE/D,SAAgB,OAAO,CACrB,SAAiB,EACjB,QAAgB,EAChB,UAAU,GAAG,CAAC,SAAS,EAAE,MAAM,CAAC;IAEhC,oEAAoE;IACpE,6CAA6C;IAC7C,wEAAwE;IACxE,kEAAkE;IAClE,kEAAkE;IAClE,UAAU;IACV,EAAE;IACF,+DAA+D;IAC/D,IAAI,OAAO,GAAG,IAAA,cAAO,EAAC,QAAQ,CAAC,CAAC;IAChC,IAAI,CAAC,IAAA,iBAAU,EAAC,SAAS,CAAC,IAAI,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;QACxD,IAAI,UAAU,GAAG,IAAA,cAAW,EAAC,OAAO,EAAE,SAAS,CAAC,CAAC;QACjD,IAAI,UAAU,GAAG,IAAA,cAAO,EAAC,UAAU,CAAC,CAAC;QACrC,IAAI,OAAO,KAAK,UAAU,EAAE,CAAC;YAC3B,SAAS,GAAG,IAAA,mCAAgB,EAAC,UAAU,EAAE,UAAU,CAAC,CAAC;YACrD,OAAO,GAAG,UAAU,CAAC;QACvB,CAAC;IACH,CAAC;IAED,IAAI,YAAY,CAAC;IAEjB,KAAK,IAAI,SAAS,IAAI,UAAU,CAAC,SAAS,EAAE,UAAU,CAAC,EAAE,CAAC;QACxD,IAAI,QAAQ,CAAC;QACb,IAAI,CAAC;YACH,QAAQ,GAAG,OAAO,CAAC,OAAO,CAAC,SAAS,EAAE;gBACpC,KAAK,EAAE,CAAC,OAAO,CAAC;aACjB,CAAC,CAAC;QACL,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACb,IAAI,GAAG,CAAC,IAAI,KAAK,kBAAkB,EAAE,CAAC;gBACpC,MAAM,GAAG,CAAC;YACZ,CAAC;YAED,IAAI,CAAC,YAAY,EAAE,CAAC;gBAClB,YAAY,GAAG,GAAG,CAAC;YACrB,CAAC;YAED,SAAS;QACX,CAAC;QACD,IAAI,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC;YAC7D,oEAAoE;YACpE,uEAAuE;YACvE,mEAAmE;YACnE,uEAAuE;YACvE,mEAAmE;YACnE,EAAE;YACF,oEAAoE;YACpE,iCAAiC;YACjC,SAAS;QACX,CAAC;QACD,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,EAAE,IAAI,EAAE,MAAgB,EAAE,QAAQ,EAAE,EAAE,CAAC;IACzE,CAAC;IAED,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,EAAE,YAAY,EAAE,CAAC;AAClD,CAAC;AAED,QAAQ,CAAC,CAAC,UAAU,CAAC,SAAiB,EAAE,UAAoB;IAC1D,MAAM,SAAS,CAAC;IAEhB,KAAK,IAAI,GAAG,IAAI,UAAU,EAAE,CAAC;QAC3B,MAAM,GAAG,SAAS,GAAG,GAAG,EAAE,CAAC;IAC7B,CAAC;IAED,KAAK,IAAI,GAAG,IAAI,UAAU,EAAE,CAAC;QAC3B,MAAM,GAAG,SAAS,SAAS,GAAG,EAAE,CAAC;IACnC,CAAC;AACH,CAAC","sourcesContent":["import { dirname, isAbsolute, resolve as pathResolve } from 'path';\nimport { explicitRelative } from '@embroider/shared-internals';\n\nexport function resolve(\n  specifier: string,\n  fromFile: string,\n  extensions = ['.hbs.js', '.hbs']\n): { type: 'found'; result: { type: 'real'; filename: string } } | { type: 'not_found'; err: Error } {\n  // require.resolve does not like when we resolve from virtual paths.\n  // That is, a request like \"../thing.js\" from\n  // \"/a/real/path/VIRTUAL_SUBDIR/virtual.js\" has an unambiguous target of\n  // \"/a/real/path/thing.js\", but require.resolve won't do that path\n  // adjustment until after checking whether VIRTUAL_SUBDIR actually\n  // exists.\n  //\n  // We can do the path adjustments before doing require.resolve.\n  let fromDir = dirname(fromFile);\n  if (!isAbsolute(specifier) && specifier.startsWith('.')) {\n    let targetPath = pathResolve(fromDir, specifier);\n    let newFromDir = dirname(targetPath);\n    if (fromDir !== newFromDir) {\n      specifier = explicitRelative(newFromDir, targetPath);\n      fromDir = newFromDir;\n    }\n  }\n\n  let initialError;\n\n  for (let candidate of candidates(specifier, extensions)) {\n    let filename;\n    try {\n      filename = require.resolve(candidate, {\n        paths: [fromDir],\n      });\n    } catch (err) {\n      if (err.code !== 'MODULE_NOT_FOUND') {\n        throw err;\n      }\n\n      if (!initialError) {\n        initialError = err;\n      }\n\n      continue;\n    }\n    if (filename.endsWith('.hbs') && !candidate.endsWith('.hbs')) {\n      // Evaluating the `handlebars` NPM package installs a Node extension\n      // that puts `*.hbs` in the automatic search path. But we can't control\n      // its priority, and it's really important to us that `.hbs` cannot\n      // shadow other extensions with higher priority. For example, when both\n      // `.ts` and `.hbs` exist, resolving is supposed to find the `.ts`.\n      //\n      // This covers the case where we found an hbs \"by accident\", when we\n      // weren't actually expecting it.\n      continue;\n    }\n    return { type: 'found', result: { type: 'real' as 'real', filename } };\n  }\n\n  return { type: 'not_found', err: initialError };\n}\n\nfunction* candidates(specifier: string, extensions: string[]) {\n  yield specifier;\n\n  for (let ext of extensions) {\n    yield `${specifier}${ext}`;\n  }\n\n  for (let ext of extensions) {\n    yield `${specifier}/index${ext}`;\n  }\n}\n"]}