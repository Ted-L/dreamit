{"version":3,"file":"describe-exports.js","sourceRoot":"","sources":["describe-exports.ts"],"names":[],"mappings":";;;;;AAOA,0CA0CC;AAhDD,sCAAoC;AAEpC,+DAAuC;AACvC,sCAAyC;AACzC,gEAAuC;AAEvC,SAAgB,eAAe,CAAC,IAAY,EAAE,iBAAmC;IAC/E,IAAI,GAAG,GAAG,IAAA,YAAK,EAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC;IACzC,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,MAAM,EAAE,CAAC;QAChC,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;IAC5D,CAAC;IACD,IAAI,KAAK,GAAgB,IAAI,GAAG,EAAE,CAAC;IAEnC,IAAA,kBAAQ,EAAC,GAAG,EAAE;QACZ,sBAAsB,CAAC,IAAwC;YAC7D,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;gBACtC,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;oBAClB,KAAK,iBAAiB,CAAC;oBACvB,KAAK,0BAA0B;wBAC7B,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,KAAK,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC;wBAE5F,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;wBAChB,MAAM;oBACR,KAAK,wBAAwB;wBAC3B,kDAAkD;wBAClD,MAAM;oBACR;wBACE,IAAA,sBAAW,EAAC,IAAI,CAAC,CAAC;gBACtB,CAAC;YACH,CAAC;YACD,IAAI,YAAC,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC;gBACnD,KAAK,IAAI,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE,CAAC;oBACnD,IAAI,YAAC,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC;wBAC3B,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;oBACzB,CAAC;gBACH,CAAC;YACH,CAAC;YACD,IAAI,YAAC,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,YAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC;gBAClG,IAAI,YAAC,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,EAAE,CAAC;oBAC7C,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;gBAC3C,CAAC;YACH,CAAC;QACH,CAAC;QACD,wBAAwB,CAAC,KAA2C;YAClE,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QACvB,CAAC;KACF,CAAC,CAAC;IACH,OAAO,EAAE,KAAK,EAAE,CAAC;AACnB,CAAC","sourcesContent":["import type { TransformOptions } from '@babel/core';\nimport { parse } from '@babel/core';\nimport type { NodePath } from '@babel/traverse';\nimport traverse from '@babel/traverse';\nimport { types as t } from '@babel/core';\nimport assertNever from 'assert-never';\n\nexport function describeExports(code: string, babelParserConfig: TransformOptions): { names: Set<string> } {\n  let ast = parse(code, babelParserConfig);\n  if (!ast || ast.type !== 'File') {\n    throw new Error(`bug in embroider/core describe-exports`);\n  }\n  let names: Set<string> = new Set();\n\n  traverse(ast, {\n    ExportNamedDeclaration(path: NodePath<t.ExportNamedDeclaration>) {\n      for (let spec of path.node.specifiers) {\n        switch (spec.type) {\n          case 'ExportSpecifier':\n          case 'ExportNamespaceSpecifier':\n            const name = spec.exported.type === 'Identifier' ? spec.exported.name : spec.exported.value;\n\n            names.add(name);\n            break;\n          case 'ExportDefaultSpecifier':\n            // this is in the types but was never standardized\n            break;\n          default:\n            assertNever(spec);\n        }\n      }\n      if (t.isVariableDeclaration(path.node.declaration)) {\n        for (let dec of path.node.declaration.declarations) {\n          if (t.isIdentifier(dec.id)) {\n            names.add(dec.id.name);\n          }\n        }\n      }\n      if (t.isFunctionDeclaration(path.node.declaration) || t.isClassDeclaration(path.node.declaration)) {\n        if (t.isIdentifier(path.node.declaration.id)) {\n          names.add(path.node.declaration.id.name);\n        }\n      }\n    },\n    ExportDefaultDeclaration(_path: NodePath<t.ExportDefaultDeclaration>) {\n      names.add('default');\n    },\n  });\n  return { names };\n}\n"]}