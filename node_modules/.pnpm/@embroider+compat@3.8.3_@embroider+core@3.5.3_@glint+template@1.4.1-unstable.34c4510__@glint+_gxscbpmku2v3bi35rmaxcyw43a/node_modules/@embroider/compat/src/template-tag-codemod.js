"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = templateTagCodemod;
const default_pipeline_1 = __importDefault(require("./default-pipeline"));
const path_1 = require("path");
const fs_1 = require("fs");
const broccoli_plugin_1 = __importDefault(require("broccoli-plugin"));
const core_1 = require("@babel/core");
const core_2 = require("@embroider/core");
const resolver_transform_1 = __importDefault(require("./resolver-transform"));
const child_process_1 = require("child_process");
const core_3 = require("@embroider/core");
function templateTagCodemod(emberApp, { shouldTransformPath = (() => true), nameHint = (path => {
    return path
        .split('/')
        .map(part => part
        .split('-')
        // capitalize first letter
        .map(inner_part => inner_part.charAt(0).toUpperCase() + inner_part.slice(1))
        .join(''))
        .join('_');
}), dryRun = false, } = {}) {
    return new TemplateTagCodemodPlugin([
        (0, default_pipeline_1.default)(emberApp, undefined, {
            staticAddonTrees: true,
            staticAddonTestSupportTrees: true,
            staticInvokables: true,
            staticEmberSource: true,
            amdCompatibility: {
                es: [],
            },
        }),
    ], { shouldTransformPath, nameHint, dryRun });
}
const TEMPLATE_ONLY_MARKER = `import templateOnlyComponent from '@ember/component/template-only';`;
const TEMPLATE_COLOCATION_MARKER = /\/\* import __COLOCATED_TEMPLATE__ from (.*) \*\//;
class TemplateTagCodemodPlugin extends broccoli_plugin_1.default {
    constructor(inputNodes, options) {
        super(inputNodes, {
            name: 'TemplateTagCodemodPlugin',
        });
        this.options = options;
    }
    async build() {
        var _a, _b;
        function* walkSync(dir) {
            const files = (0, fs_1.readdirSync)(dir);
            for (const file of files) {
                const pathToFile = (0, path_1.join)(dir, file);
                const isDirectory = (0, fs_1.statSync)(pathToFile).isDirectory();
                if (isDirectory) {
                    yield* walkSync(pathToFile);
                }
                else {
                    yield pathToFile;
                }
            }
        }
        this.inputPaths[0];
        const tmp_path = (0, fs_1.readFileSync)(this.inputPaths[0] + '/.stage2-output').toLocaleString();
        const compatPattern = /#embroider_compat\/(?<type>[^\/]+)\/(?<rest>.*)/;
        const resolver = new core_2.ResolverLoader(process.cwd()).resolver;
        const hbs_file_test = /[\\/]rewritten-app[\\/]components[\\/].*\.hbs$/;
        // locate ember-source for the host app so we know which version to insert builtIns for
        const emberSourceEntrypoint = require.resolve('ember-source', { paths: [process.cwd()] });
        const emberVersion = JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(emberSourceEntrypoint, '../../package.json')).toString()).version;
        const ember_template_compiler = resolver.nodeResolve('ember-source/vendor/ember/ember-template-compiler', (0, path_1.resolve)((0, core_3.locateEmbroiderWorkingDir)(process.cwd()), 'rewritten-app', 'package.json'));
        if (ember_template_compiler.type === 'not_found') {
            throw 'This will not ever be true';
        }
        const embroider_compat_path = require.resolve('@embroider/compat', { paths: [process.cwd()] });
        const babel_plugin_ember_template_compilation = require.resolve('babel-plugin-ember-template-compilation', {
            paths: [embroider_compat_path],
        });
        const babel_plugin_syntax_decorators = require.resolve('@babel/plugin-syntax-decorators', {
            paths: [embroider_compat_path],
        });
        const babel_plugin_syntax_typescript = require.resolve('@babel/plugin-syntax-typescript', {
            paths: [embroider_compat_path],
        });
        const resolver_transform = (0, resolver_transform_1.default)({
            appRoot: process.cwd(),
            emberVersion: emberVersion,
            externalNameHint: this.options.nameHint,
        });
        for await (const current_file of walkSync(tmp_path)) {
            if (hbs_file_test.test(current_file) && this.options.shouldTransformPath(current_file)) {
                const template_file_src = (0, fs_1.readFileSync)(current_file).toLocaleString();
                // run the template transformations using embroider resolver information
                // to replace template values with js import syntax used in g(j/t)s
                let transformed_source = (_b = (_a = (0, core_1.transformSync)((0, core_2.hbsToJS)(template_file_src), {
                    plugins: [
                        [
                            babel_plugin_ember_template_compilation,
                            {
                                compilerPath: ember_template_compiler.filename,
                                transforms: [resolver_transform],
                                targetFormat: 'hbs',
                            },
                        ],
                    ],
                    filename: current_file,
                })) === null || _a === void 0 ? void 0 : _a.code) !== null && _b !== void 0 ? _b : '';
                // using transformSync to parse and traverse in one go
                // we're only extracting the transformed template information from previous step
                // and preserving it for later assembly in the backing class
                const import_bucket = [];
                let template_tag_value = '';
                (0, core_1.transformSync)(transformed_source, {
                    plugins: [
                        function template_tag_extractor() {
                            return {
                                visitor: {
                                    ImportDeclaration(import_declaration) {
                                        const extractor = import_declaration.node.source.value.match(compatPattern);
                                        if (extractor) {
                                            const result = resolver.nodeResolve(extractor[0], current_file);
                                            if (result.type === 'real') {
                                                // find package there the resolver is pointing
                                                const owner_package = resolver.packageCache.ownerOfFile(result.filename);
                                                let relative_import_path = (0, path_1.relative)(owner_package.root, result.filename);
                                                // for addons strip off appPublicationDir from relative path
                                                // we do this on app files as well as they don't contain the
                                                // path that we strip off
                                                // this makes sure that ambiguous imports get properly attributed
                                                relative_import_path = relative_import_path.replace('_app_/', '');
                                                // remove the extension to match what a developer would normally write
                                                relative_import_path = relative_import_path.slice(0, -(0, path_1.extname)(relative_import_path).length);
                                                // change import path to real one
                                                import_declaration.node.source.value = owner_package.name + '/' + relative_import_path;
                                                import_bucket.push(import_declaration);
                                            }
                                        }
                                        else if (import_declaration.node.source.value.indexOf('@ember/template-compilation') === -1) {
                                            import_bucket.push(import_declaration);
                                        }
                                    },
                                    CallExpression(path) {
                                        // reverse of hbs to js
                                        // extract the template string to put into template tag in backing class
                                        if ('name' in path.node.callee &&
                                            path.node.callee.name === 'precompileTemplate' &&
                                            path.node.arguments &&
                                            'value' in path.node.arguments[0]) {
                                            template_tag_value = `<template>\n\t${path.node.arguments[0].value}\n</template>`;
                                        }
                                    },
                                },
                            };
                        },
                    ],
                });
                //find backing class
                const backing_class_resolution = resolver.nodeResolve('#embroider_compat/' + (0, path_1.relative)(tmp_path, current_file).replace(/[\\]/g, '/').slice(0, -4), tmp_path);
                const backing_class_filename = 'filename' in backing_class_resolution ? backing_class_resolution.filename : '';
                // this can be either a generated js file in case of template only components
                // the js or ts file depending on what the app is configured
                const backing_class_src = (0, fs_1.readFileSync)(backing_class_filename).toString();
                const is_typescript = (0, path_1.extname)(backing_class_filename) === '.ts';
                let insert_imports_byte_count = null;
                let insert_template_byte_count = null;
                const is_template_only = backing_class_src.indexOf(TEMPLATE_ONLY_MARKER) !== -1;
                // we parse the backing class to find the insert points for imports and template
                (0, core_1.transformSync)(backing_class_src, {
                    plugins: [
                        [
                            is_typescript ? babel_plugin_syntax_typescript : babel_plugin_syntax_decorators,
                            { decoratorsBeforeExport: true },
                        ],
                        function glimmer_syntax_creator( /* babel */) {
                            return {
                                name: 'test',
                                visitor: {
                                    ImportDeclaration(import_declaration) {
                                        insert_imports_byte_count = import_declaration.node.end;
                                    },
                                    ExportDefaultDeclaration(path) {
                                        // convention is that we have a default export for each component
                                        // we look for the closing bracket of the class body
                                        path.traverse({
                                            ClassBody(path) {
                                                // we substract 1 to find the byte right before the final closing bracket `}`
                                                // this is the default insert point for template tag though it could live anywhere inside the class body
                                                // possible future point to add option for putting template first thing in class
                                                insert_template_byte_count = path.node.end ? path.node.end - 1 : 0;
                                            },
                                        });
                                    },
                                },
                            };
                        },
                    ],
                });
                // list of imports needed by the previous hbs template extracted in second step
                const hbs_template_required_imports = import_bucket.join('\n');
                // we extracted all we needed from transformed_source so we switch to the second phase
                // transforming the backing class into what will be our final output
                transformed_source = backing_class_src;
                if (is_template_only) {
                    // because we can't inject a comment as the default export
                    // we replace the known exported string
                    transformed_source = transformed_source.replace('templateOnlyComponent()', template_tag_value);
                    // we clean known markers from generated files
                    transformed_source = transformed_source.replace(TEMPLATE_ONLY_MARKER, hbs_template_required_imports);
                    transformed_source = transformed_source.replace(TEMPLATE_COLOCATION_MARKER, '');
                }
                else {
                    // we modify the source from end to start in order to keep our byte counts valid through the transforms
                    if (insert_template_byte_count) {
                        // first we split the backing class at the byte count we found during backing class parsing
                        // then concat the string back together adding the transformed template in the middle
                        transformed_source =
                            transformed_source.substring(0, insert_template_byte_count) +
                                '\n' +
                                template_tag_value +
                                '\n' +
                                transformed_source.substring(insert_template_byte_count, transformed_source.length);
                    }
                    if (insert_imports_byte_count) {
                        // first we split the backing class at the byte count we found during backing class parsing
                        // then concat the string back together adding the transformed template in the middle
                        transformed_source =
                            transformed_source.substring(0, insert_imports_byte_count) +
                                '\n' +
                                hbs_template_required_imports +
                                '\n' +
                                transformed_source.substring(insert_imports_byte_count, transformed_source.length);
                    }
                    transformed_source = transformed_source.replace(TEMPLATE_COLOCATION_MARKER, '');
                }
                const dryRun = this.options.dryRun ? '--dry-run' : '';
                // work out original file path in app tree
                const app_relative_path = (0, path_1.join)('app', (0, path_1.relative)(tmp_path, current_file));
                const new_file_path = app_relative_path.slice(0, -4) + (is_typescript ? '.gts' : '.gjs');
                // write glimmer file out
                if (this.options.dryRun) {
                    console.log('Write new file', new_file_path, transformed_source);
                }
                else {
                    (0, fs_1.writeFileSync)((0, path_1.join)(process.cwd(), new_file_path), transformed_source, { flag: 'wx+' });
                }
                // git rm old files (js/ts if exists + hbs)
                let rm_hbs = await execute(`git rm ${app_relative_path} ${dryRun}`, {
                    pwd: process.cwd(),
                });
                console.log(rm_hbs.output);
                if (!is_template_only) {
                    // remove backing class only if it's not a template only component
                    // resolve relative path to rewritten-app
                    const app_relative_path = (0, path_1.join)('app', (0, path_1.relative)(tmp_path, backing_class_filename));
                    let rm_js = await execute(`git rm ${app_relative_path} ${dryRun}`, {
                        pwd: process.cwd(),
                    });
                    console.log(rm_js.output);
                }
            }
        }
    }
}
async function execute(shellCommand, opts) {
    let env;
    if (opts === null || opts === void 0 ? void 0 : opts.env) {
        env = { ...process.env, ...opts.env };
    }
    let child = (0, child_process_1.spawn)(shellCommand, {
        stdio: ['inherit', 'pipe', 'pipe'],
        cwd: opts === null || opts === void 0 ? void 0 : opts.pwd,
        shell: true,
        env,
    });
    let stderrBuffer = [];
    let stdoutBuffer = [];
    let combinedBuffer = [];
    child.stderr.on('data', data => {
        stderrBuffer.push(data);
        combinedBuffer.push(data);
    });
    child.stdout.on('data', data => {
        stdoutBuffer.push(data);
        combinedBuffer.push(data);
    });
    return new Promise(resolve => {
        child.on('close', (exitCode) => {
            resolve({
                exitCode,
                get stdout() {
                    return stdoutBuffer.join('');
                },
                get stderr() {
                    return stderrBuffer.join('');
                },
                get output() {
                    return combinedBuffer.join('');
                },
            });
        });
    });
}
//# sourceMappingURL=template-tag-codemod.js.map